<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <meta name="Author" content="Sergei Kuchin">
  <meta name="GENERATOR"
 content="Mozilla/4.77 [en] (Win95; U) [Netscape]">
  <meta name="KeyWords"
 content="OTL, Oracle, ODBC, DB2, CLI, database API, C++, Template Library">
  <title>OTL 4.0, Examples</title>
</head>
<body>
<center>
<h1>OTL 4.0, OTL connect class</h1>
</center>
<h1>
<a name="otl_connect_class"></a>OTL connect class</h1>
This class encapsulates <i>connect </i>functions: connect,
disconnect,
commit, roll back, etc. In other words, the otl_connect class is the
class
for creating and handling <i>connect</i> objects together with
transaction
management.
<pre><font size="+2">class otl_connect{&nbsp;<br>public:</font></pre>
<ul>
  <li> <i><a name="connected"></a>Connection </i>flag which shows
whether the object is
connected
to the
database or not. The flag only shows that the otl_connect object was
successfully connected to the database.If there has not been any
database calls on the otl_connect object, and, say, the database
connection was closed, the flag would still be set to 1 (true). In
order to check out whether the database connect still exists or not, a
"heartbeat" database round-trip needs to be made, say, a "SELECT
&lt;current time&gt; FROM &lt;dual table&gt;", or an actual,
application related SQL statement. <br>
  </li>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int connected;</pre>
<ul>
  <li> <a name="otl_initialize"></a>Static (in class) function to
initialize the
OTL environment. It needs to be called only once at the beginning of
the
program before making the very first connection to the database. The <i>threaded_mode
    </i>is a parameter for specifying if the program is running in the
multi-threaded
mode but it does not automatically guarantee thread safety, because OTL
does not set any mutex locks or critical sections. Threaded_mode = 1
means
the multi-threaded mode, 0 -- the single threaded mode.</li>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static int otl_initialize(const int threaded_mode=0);</pre>
<ul>
  <li> <a name="otl_terminate"></a>Static (in class) function to
terminate
the
Oracle 8i/9i OCI environment. It needs to be called only once at the
end
of the program after closing the very last database connection. This
function
is just a wrapper around the OCITerminate() call. Usually, in
multi-threaded
programs, in order to be able to terminate/end the main thread of
control,
otl_terminate needs to be called, because it detaches the process from
the OCI client side shared memory, and does something else, that is not
well documented.</li>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static int otl_terminate(void);</pre>
<blockquote>
  <li><a name="cancel"></a><i>OTL/OCI8, OTL/OCI9 only<b>. </b></i>Cancel
any
operation / database call, executing / active in the connect object /
database
session. Say, the database session is in the <i>active </i>state, or,
in
other words, has a running SQL statement in a thread. This function can
be called from another thread, to cancel the execution of the SQL
statement
asynchronously. Right after the cancel() call returns, the first thread
will raise an otl_exception with the following message: <i>user
requested
cancel of current operation.</i></li>
</blockquote>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void cancel(void);</pre>
<ul>
  <li> <a name="change_password"></a><i>OTL/OCI8i, OTL/OCI9i only</i>.
This function
changes Oracle user's passwords. The program needs to attach to an
Oracle
server, and only then this function can be called.</li>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void change_password<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (const char* user_name,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char* old_password,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char* new_password<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</pre>
<blockquote>
  <li><a name="set_transaction_isolation_level"></a>Set
transaction
isolation
level. <i>OTL/DB2-CLI, OTL/ODBC only</i>. The function allows the user
to set the following levels: READ COMMITTED, READ UNCOMMITTED,
REPEATABLE
READ, SERIALIZABLE. For more detail on the transaction isolation
levels,
see the regular database manuls.</li>
</blockquote>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void set_transaction_isolation_level(const long int level);</pre>
<blockquote>OTL/ODBC and OTL/DB2-CLI define the following global
constants,
which can be used as substitutes for the <i>level </i>parameter of
the
function:
  <ul>
    <ul>
      <li> <b>otl_tran_read_uncommitted - </b>READ UNCOMITTED</li>
      <li> <b>otl_tran_read_committed - </b>READ COMITTED</li>
      <li> <b>otl_tran_repetable_read -</b>REPEATABLE READ</li>
      <li> <b>otl_tran_serializable - </b>SERIALIZABLE</li>
    </ul>
  </ul>
</blockquote>
<ul>
  <li> <a name="set_max_long_size"></a>Set the maximum buffer size for
operations
with Large Objects: <a href="otl3_bind_variables.htm#varchar_long">varchar_long</a>,
    <a href="otl3_bind_variables.htm#raw_long">raw_long</a>, <a
 href="otl3_bind_variables.htm#clob">clob</a>
and <a href="otl3_bind_variables.htm#blob">blob</a>. This function
needs
to be called in order to increase the buffer size (default size is
32767).</li>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void set_max_long_size(const int amax_size);</pre>
<ul>
  <li>Get the maximum buffer size for operations with Large Objects: <a
 href="otl3_bind_variables.htm#varchar_long">varchar_long</a>, <a
 href="otl3_bind_variables.htm#varchar_long">raw_long</a>, <a
 href="otl3_bind_variables.htm#clob">clob</a>
and <a href="otl3_bind_variables.htm#blob">blob</a>.</li>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int get_max_long_size(void);</pre>
<ul>
  <li>This function works in OTL 4.0/ODBC and OTL 4.0/DB2-CLI only, and
it
has
not effect in OTL 4.0/OCIx. Set the cursor type. Once the cursor type
is
set, the setting will be propagated to all SELECT statements opened via
the <a href="otl3_stream_class.htm">otl_stream</a> class in the
current
connect object.</li>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void set_cursor_type(const int acursor_type=0);</pre>
<ul>
  <font size="-1">The following cursor types are available (for more
detail,
see the ODBC Programmer's Guide, or the DB2 CLI Programmer's Guide):</font>
  <ul>
    <li> <font size="-1">SQL_CURSOR_FORWARD_ONLY (default setting)</font></li>
    <li> <font size="-1">SQL_CURSOR_STATIC</font></li>
    <li> <font size="-1">SQL_CURSOR_KEYSET_DRIVEN</font></li>
    <li> <font size="-1">SQL_CURSOR_DYNAMIC</font></li>
  </ul>
</ul>
<ul>
  <li>This function works in OTL 4.0/ODBC, OTL 4.0/DB2-CLI for Windows
only,
and has no effect in OTL 4.0/OCIx. Set the timeout for the current
connect
object. Once the timeout is set, the setting will be effective for all
SQL statements opened in the current connect object. The time unit for
the function is 1 second, e.g. setting 60 means the timeout of 1 minute.</li>
  <p><br>
If a timeout is set (this function gets called) before logging onto
/ connecting to the database, and if the logon / connect request is not
getting through to the database, the request will time out, according
to
the time interval that was set as a timeout. </p>
  <p>In the future, if the OCI provides similar functionality, this
function
may be implemented. In OCIx, a different technique is used to simulate
timeouts: create a worker thread that will execute your SQL statement,
and a control thread with a timer. If the timer goes off and the SQL
statement
is still executing, the control thread can call otl_connect::<a
 href="#cancel">cancel</a>()
on the same connect object that is being used to execute the SQL
statement.</p>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="set_timeout"></a>void set_timeout(const int atimeout=0);</pre>
<ul>
  <li> <a name="constructor"></a>General constructor. It creates an
otl_connect
object and then calls the <a href="#rlogon">rlogon()</a> function.</li>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; otl_connect(const char* connect_str,const int auto_commit=0);</pre>
<ul>
  <li> <a name="rlogon"></a>Log on / connect to the database.</li>
</ul>
<ul>
  <pre>&nbsp; void rlogon(const char* connect_str,const int auto_commit=0);</pre>
</ul>
<ul>
  <font size="-1">OTL 4.0/OCIx, OTL 4.0/ODBC, and OTL 4.0/DB2-CLI have
different styles of <i>connect strings:<br>
  <br>
  </i></font>
  <ul>
    <li> <font size="-1">OTL 4.0/OCIx style<br>
      <br>
      </font></li>
    <ul>
      <li> <font size="-1">"USER/PASSWORD" (for local Oracle
connections)</font></li>
      <li> <font size="-1">"USER/PASSWORD@TNS_ALIAS" (for remote
Oracle
connections
via SQL*Net)<br>
        <br>
        </font></li>
    </ul>
    <li> <font size="-1">OTL 4.0/ODBC and OTL 4.0/DB2-CLI style<br>
      <br>
      </font></li>
    <ul>
      <li> <font size="-1">"USER/PASSWORD/@DSN" (Oracle-like style for
ODBC or DB2-CLI
connections)</font></li>
      <li> <font size="-1">"DSN=value;UID=value;PWD=value" (ODBC-like
style for ODBC
or DB2-CLI connection)</font></li>
    </ul>
  </ul>
</ul>
<div style="margin-left: 40px;"><font size="-1"><a
 name="AT_IN_CONNECT_STR"></a>In OTL/ODBC/OCI8/OCI8i/OCI9i/OCI10g, it
is possible for a&nbsp;
password value to have a "@" (commercial at character) in it. In order
to specify a "@" in a password, the character has to be prefixed&nbsp;
with a "<span style="font-weight: bold;">\</span>", for example:
"userid/pass\\@word@DSN", or "UID=scott;PWD=ti\\@ger;DSN=mssql" (in
these examples, "\\" was used because the examples show C++ string
literals).<br>
<br>
</font></div>
<ul>
  <a name="auto_commit"></a>The auto_commit parameter in this function
is
used for setting the connection "auto-commit" mode. This means that
every
single SQL statement, executed in the connection, will be automatically
committed. This auto-commit mode has nothing to do with the <a
 href="otl3_stream_class.htm#set_commit">otl_stream
auto-commit</a> mode. In order to set the mode to "auto-commit", the
auto_commit
parameter needs to be set to 1. By default, it is 0, meaning that
"auto-commit"
is off.
  <p>In Oracle 7, ODBC and DB2-CLI, this mode is called "auto-commit".
In
Oracle 8/8i/9i, it is called "commit-on-success." It is not quite clear
why in Oracle 8 the term was changed to "commit-on-success" and pushed
from the level of the connection down to the level of the SQL statement
execution.</p>
</ul>
<ul>
  <li> <a name="attach7"></a>Log on / connect to / attach to the
primary
database
connection, which was made in Pro*C/C++ or any other third-party
library.
This function works for <b><i>OTL/OCI7</i></b> only, and it helps to
make
transition from the legacy environment to the OTL environment smoother.
See also example <a href="otl3_ex58.htm">58</a>.</li>
</ul>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <tt>void
rlogon(Lda_Def* lda);</tt>
<ul>
  <li> <a name="ext_logon_odbc"></a>Log on / connect to / attach to
the
primary
database connection, which was made in straight ODBC, DB2-CLI, or any
other
third-party (ODBC, or DB2-CLI based) library. This function works for <b><i>OTL/ODBC,
DB2-CLI</i></b> only, and it helps to make transition from the legacy
environment
to the OTL environment smoother.</li>
</ul>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void rlogon(HENV henv,
//
environment handle</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
HDBC hdbc, // database connect handle</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const int auto_commit=0 // connect auto-commit mode</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
);<br>
</tt>
<ul>
  <li> <a name="logon_odbc_unicode"></a>Log on / connect to the
database (DSN / database alias). This function works for <b><i>OTL/ODBC,
DB2-CLI</i></b> only, when Unicode ODBC driver functions are enabled
(via<span style="font-family: monospace;"> #define UNICODE, #define
_UNICODE). </span>The
function allows Unicode user names, passwords, and DSNs to be passed
into the ODBC layer.<span style="font-family: monospace;"><br>
    </span></li>
</ul>
<span style="font-family: monospace;">#if defined(<a
 href="otl3_compile.htm#OTL_UNICODE_EXCEPTION_AND_RLOGON">OTL_UNICODE_EXCEPTION_AND_RLOGON</a>)<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; void rlogon(const <a
 href="otl3_compile.htm#OTL_UNICODE_CHAR_TYPE">OTL_UNICODE_CHAR_TYPE</a>*
username, // user name<br>
&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const OTL_UNICODE_CHAR_TYPE* passwd, // password<br>
&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const OTL_UNICODE_CHAR_TYPE* dsn, // data source name<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const int auto_commit=0 // connect
auto-commit mode<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
);<br>
<br>
#endif<br>
</span><tt><br>
</tt>
<ul>
  <li><a name="ext_otl_connect_odbc"></a>General constructor: connect
to
the
primary database connection, which was made in straight ODBC, DB2-CLI,
or any other third-party (ODBC, or DB2-CLI based) library. This
function
works for <b><i>OTL/ODBC, DB2-CLI</i></b> only, and it helps to make
transition
from the legacy environment to the OTL environment smoother.</li>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; otl_connect(HENV henv, // environment handle<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HDBC hdbc, // database connect handle<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const int auto_commit=0 // connect auto-commit mode<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</pre>
<ul>
  <li> <a name="attach8"></a>Log on / connect to / attach to the
primary
database
connection, which was made in Pro*C/C++ or any other third-party
library.
This function works for <b><i>OTL/OCI8/8i/9i</i></b> only, and it
helps
to make integration of OTL/OCI8/8i/9i and the Pro*C/C++ environment
smooth
and easy. In order to use this function in the Pro*C/C++ environment,
#define
OTL_ORA8_PROC needs to be set at the beginning of the program. For more
detail, see example <a href="otl3_ex59.htm">59</a></li>
  <p><i>envhp</i> is a pointer to the OCI8/8i/9i environment handle,
which
needs to be obtained by calling the <i>SQLEnvGet</i> function. <br>
  <i>svchp </i>is a pointer to the OCI8/8i/9i service context handle,
which needs to be obtained by calling the <i>SQLSvcCtxGet</i> function.</p>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void rlogon(OCIEnv* envhp, OCISvcCtx* svchp);<br><br></pre>
<ul>
  <li><a name="rlogon_xa"></a><b><i>OTL/OCI8/8i/9i/10g, </i></b>connect
to the database and set the following connection attributes that are
required by the Oracle XA Library: server external name, server
internal name. <br>
    <br>
    <pre>&nbsp;void rlogon(const char* connect_str,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const int aauto_commit=0,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char* xa_server_external_name=0,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char* xa_server_internal_name=0,<br>#if defined(<a
 href="otl3_compile.htm#OTL_ORA_OCI_ENV_CREATE">OTL_ORA_OCI_ENV_CREATE</a>)<br>             bool threaded_mode=false<br>#endif<br>            );<br></pre>
  </li>
</ul>
<ul>
  <li> <a name="logoff"></a>Logs off / disconnects from the database.
In
case
if the primary connection was done in Pro*C/C++ (OTL/OCIx), this
function
just detaches from that connection without actually disconnecting from
the database.</li>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void logoff(void);</pre>
<ul>
  <li> <a name="attach_detach"></a>Attach to / detach from Oracle (<b><i>OTL/OCI8/8i/9i</i></b>
only). These functions are wrappers around the ServerAttach and
ServerDetach
functions of the OCI8. The main reason to have separate functions to
attach
to the server and then begin a session is performance. For more detail,
see Oracle's regular manuals. These functions, along with the <a
 href="#session_begin">session_begin</a>
and <a href="#session_end">session_end</a> functions, could be used
for
implementing a connection management mechanism that is more efficient
than
the traditional connection pooling. See also example <a
 href="otl3_ex60.htm">60</a>.<br>
  </li>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp; <a name="server_attach"></a>void server_attach(const char* tnsname=0,&nbsp;<br>                           const char* xa_server_external_name=0,<br>                           const char* xa_server_internal_name=0,<br>#if defined(<a
 href="otl3_compile.htm#OTL_ORA_OCI_ENV_CREATE">OTL_ORA_OCI_ENV_CREATE</a>)<br>                           bool threaded_mode=false<br>#endif<br>                          )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // tnsname (TNS alias from TNSNAMES.ORA file) can be specified&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // in order to connect to a remote Oracle 8 server.&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // For local connections, tnsname defaults to 0.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The function attaches to the database server (local or remote).<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The following "server attachment" attributes that are <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // required by the Oracle XA Library can be also specified:<br>         // server external name, server internal name. Also see <a
 href="#rlogon_xa">rlogon</a>().<br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a
 name="server_detach"></a>void server_detach(void); // detach from the Oracle 8 server</pre>
<ul>
  <li>Begin / end Oracle 8 session (<b><i>OTL/OCI8/8i/9i</i></b> only).
These
functions complement the server <a href="#attach_detach">attach/detach</a>
suite of functions, and are used to begin / end an Oracle 8 session.
The
main reason to have separate server attach/detach and session begin/end
groups of function is performance. session_begin() is approximately
50-100
times faster than the normal <a href="#rlogon">rlogon</a>(). These
functions,
along with the <a href="#attach_detach">server_attach</a>() and <a
 href="#server_detach">server_detach</a>()
functions, could be used for implementing a connection management
mechanism
that is several times more efficient [thus, more scalable] than the
traditional
connection pooling.</li>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="session_begin"></a>void session_begin<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (const char* username, // user name, e.g. "scott"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char* password, // password, e.g. "tiger"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const int auto_commit=0, // session <a
 href="#auto_commit">auto-commit</a> mode<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const int session_mode=OCI_DEFAULT<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // OCI_SYSDBA -- in this mode, the user is authenticated for SYSDBA<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // access.&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // OCI_SYSOPER -- in this mode, the user is authenticated<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // for SYSOPER access.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a
 name="session_end"></a>void session_end(void);</pre>
<ul>
  <li>Session reopen (<b><i>OTL/OCI8/8i/9i</i></b> only). If a session
was
started
via <a href="#session_begin">session_begin</a>() for a given <i>username/password</i>
and then closed via <a href="#session_end">session_end</a>(), another
session
can be started faster (5-10%) for the same username/password via
session_reopen().
This function takes advantage of the fact that the username and
password
attributes of the OCI8 internal connect structure have been already set
by the previous session_begin() function call. If a session has been
started
via session_reopen(), it can be closed by calling session_end().&nbsp; </li>
  <p>Also, see example <a href="otl3_ex61.htm">61</a></p>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="session_reopen"></a>void session_reopen(const int aauto_commit=0 // session <a
 href="#auto_commit">auto-commit</a> mode<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</pre>
<ul>
  <li>Commit transaction. In the otl_connect object, Oracle, ODBC and
DB2-CLI
connections, by default, are set to <i>auto-commit off. </i>This
means
that all transactions need to be commited by explicitly calling the
commit()
function. It is not recommended to use connections that are set to <i>auto-commit
on.</i></li>
  <pre>   <a name="commit"></a>void commit(void);<br><br></pre>
</ul>
<ul>
  <li>Commit transaction asynchronously, same as commit and forget /
commit with no wait. At the moment, avalaible only for Oracle 10g
Release 2 (Oracle 10.2). As soon as the rest of the database vendors
release a similar feature, it will be implemented in OTL.<br>
  </li>
</ul>
<ul>
  <pre>#if defined(<a href="otl3_compile.htm#OTL_ORA10G_R2">OTL_ORA10G_R2</a>)<br>&nbsp;  <a
 name="commit_nowait"></a>void commit_nowait(void);<br>#endif<br></pre>
</ul>
<ul>
  <li>Roll back transaction</li>
  <pre>&nbsp; void rollback(void);</pre>
  <li>Set otl_connect's <a href="#auto_commit">auto-commit</a> OFF and
ON,
within
one open session/connect. These two functions are for partial backward
compatibility only.</li>
  <pre>&nbsp;&nbsp;<a name="auto_commit_off"></a>void auto_commit_off(void);<br>&nbsp;&nbsp;<a
 name="auto_commit_on"></a>void auto_commit_on(void);</pre>
  <li> <a name="set_stream_pool_size"></a>Set the <a
 href="otl3_stream_pooling.htm">otl_stream
pool</a> size. This function can be activated with #define <a
 href="otl3_compile.htm#OTL_STREAM_POOLING_ON">OTL_STREAM_POOLING_ON,</a>
used together with #define <a href="otl3_compile.htm#OTL_STL">OTL_STL</a>.
If OTL_STREAM_POOLING_ON is defined in the program, the function body
gets
included into the target code. Also, a default stream pool gets
allocated
as part the otl_connect object, even if the function doesn't get
called.
Therefore, a call to the function will reallocate all the resources,
allocated
by the default stream pool, or by previous calls to
set_stream_pool_size().</li>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void set_stream_pool_size<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (const int max_size=otl_max_default_pool_size);</pre>
<ul>
  <li> <a name="set_character_set"></a>This function is available for
OTL/<b><i>OCI8i/9i</i><span style="font-style: italic;">/10g</span></b>
under #define <a href="otl3_compile.htm#OTL_UNICODE">OTL_UNICODE</a>
only.
In Unicode OTL, the Oracle database default or national character set
is
allowed to be set:</li>
  <br>
&nbsp;
  <ul>
    <li>SQLCS_IMPLICIT -- database default (implicit) character set</li>
    <li>SQLCS_NCHAR -- database national (second) character set.&nbsp; </li>
    <p><tt>void set_character_set(const int char_set=SQLCS_IMPLICIT);</tt></p>
  </ul>
  <p><br>
The default character set (SQLCS_IMPLICIT) needs to be set when
Unicode containers are used with the VARCHAR2, CHAR, LONG, and CLOB
column
types. In the case if Unicode containers are used with NVARCHAR2,
NCAHR,
and NCLOB datatypes, the national character set (SQLCS_NCHAR) needs to
be set. </p>
  <p>SQLCS_IMPLICIT, and SQLCS_NCHAR are defined by the OCI header
files. </p>
  <p>Since this function is part of the otl_connect class, all
otl_streams,
that gets opened via a concrete connect object, will use the character
set, that was set by the function. </p>
  <p>The semantic of :var&lt;<a href="otl3_bind_variables.htm#char">char</a>[...]...&gt;
declaration of string bind variables was extended to accomodate the
Unicode
strings. For example, char[20] means a string of 19 double-byte Unicode
characters, plus 19 double-byte possible surrogate characters, plus one
double-byte null terminator. It sounds a little complicated, but that
is
just a reflection of a plethora of Unicode standards, coding
techniques.
It is strongly recommended to read the Unicode standards themselves,
then
the Oracle implementations the Unicode. By the way, Oracle 8i and 9i
differ
in that regard substantially.<br>
  <br>
  </p>
</ul>
<ul>
  <li><a name="set_throw_on_sql_success_with_info"></a>OTL/ODBC,
OTL/DB2-CLI only. Set the "OTL throws on SQL_SUCCESS_WITH_INFO"" flag.
When the flag is set, and SQLExecDirect() / SQLExecute() function
returns SQL_SUCCESS_WITH_INFO, OTL throws an otl_exception. This is
useful for communicating more information from the SQL call, especially
if the call is a call to a stored procedure, or a Transact-SQL batch
that may return more diagnostic information than usual. The function is
enabled only when #define OTL_THROWS_ON_SQL_SUCCES_WITH_INFO is defined.<br>
  </li>
  <pre>#if defined(<a
 href="otl3_compile.htm#OTL_THROWS_ON_SQL_SUCCESS_WITH_INFO">OTL_THROWS_ON_SQL_SUCCESS_WITH_INFO</a>)<br>&nbsp; void set_throw_on_sql_success_with_info(const bool throw_flag=false);<br>#endif<br><br></pre>
  <li><a name="operator_ll"></a>Send a string to the otl_connect
object. If the object is not connected to a database then the string is
a connection
string in the "userid/passwd@db" format and it makes the object connect
to the database. If the object is already connected, the string is a
static SQL statement that the connect object executes immediately.<br>
    <br>
    <tt>otl_connect&amp; operator&lt;&lt;(const char* str);<br>
    <br>
    <br>
    </tt></li>
  <li><a name="operator_lle"></a>Send a string to the otl_connect
object. The connect object saves the string for further use with
operator <a href="#operator_gg">&gt;&gt;</a>(). The string is an SQL
statement with placeholders that could be sent to an otl_stream object.
In other words, this operator is a deferred SQL statement. <br>
    <br>
    <tt>otl_connect&amp; operator&lt;&lt;=(const char* str);<br>
    <br>
    </tt></li>
  <li><a name="operator_gg"></a>Send the SQL statement that was saved
with operator <a href="operator_lle">&lt;&lt;=</a> to an otl_stream
object. It makes the otl_stream object open the SQL statement. If there
was no SQL statement previously save by the connect object, the connect
object sends the following string to the otl_stream: <span
 style="font-family: monospace;">"*** INVALID COMMAND ***"</span>.,
which causes an SQL parse error in the otl_stream, which ends up in an
otl_exception.<br>
    <br>
    <tt>otl_connect&amp; operator&gt;&gt;(otl_stream&amp; s);<br>
    <br>
    </tt></li>
  <li><a name="direct_exec"></a>Direct execution of a static SQL
statement, the function returns the
Rows Processed Count (RPC)<br>
    <br>
    <tt>long direct_exec(const char *sqlstm, // SQL Statement<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
int ignore_error =</tt><tt> </tt><a
 href="otl3_exception_class.htm#enum"><span
 style="font-family: monospace;">otl_exception::enabled</span></a><tt>
// "ignore error" flag </tt><br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
);<br>
    <br>
    </tt></li>
  <li><a name="syntax_check"></a>Parses a static SQL statement,&nbsp;
raises an <a href="otl3_exception_class.htm">otl_exception</a> if
there is an SQL error.<br>
    <br>
    <tt>void syntax_check(const char *sqlstm // SQL Statement<br>
    </tt><tt>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
);</tt><br>
    <tt><br>
    </tt></li>
</ul>
<ul>
</ul>
<pre><font size="+2">}; // end of otl_connect</font></pre>
<center>
<hr width="100%">
<p><a href="otl3_bind_variables.htm">Prev</a> <a
 href="otl3_exception_class.htm">Next</a><a href="otl3.htm">Contents</a><a
 href="home.htm">Go
Home</a></p>
</center>
<p>Copyright &copy; 1996, 2007, Sergei Kuchin, email: <a
 href="mailto:skuchin@ispwest.com">skuchin@ispwest.com</a>,
<a href="mailto:skuchin@gmail.com">skuchin@gmail.com</a>.&nbsp;
<script language="JavaScript"><!-- hide from old browsers
 var modDate = new Date(document.lastModified)
 document.write("<i> Last Updated:</i> " + (modDate.getMonth()+1) + "/" + 
                modDate.getDate() + "/" + "0"+(modDate.getYear())%100+".");
 //-->
 </script></p>
<p><i>Permission to use, copy, modify and redistribute this document
for
any purpose is hereby granted without fee, provided that the above
copyright
notice appear in all copies.</i>
</p>
</body>
</html>
