/*
 * Copyright (C) 2004-2006  Autodesk, Inc.
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of version 2.1 of the GNU Lesser
 * General Public License as published by the Free Software Foundation.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */
#include "stdafx.h"
#include "Fdo/Pvc/FdoRdbmsPvcInsertHandler.h"
#include <Sm/Lp/ObjectPropertyDefinition.h>
#include <Sm/Lp/ObjectPropertyClass.h>
#include <Sm/Lp/PropertyMappingSingle.h>
#include "FdoRdbmsSchemaUtil.h"
#include "FdoRdbmsLobUtility.h"

FdoRdbmsPvcInsertHandler::FdoRdbmsPvcInsertHandler( ) :
    mNextQidToFree(0),
	mFdoConnection( NULL ),
	mInsertAutoIncrementProperties( false ),
	mBindUnsetValues( true )
{
}

FdoRdbmsPvcInsertHandler::FdoRdbmsPvcInsertHandler( FdoRdbmsConnection *connection ) :
    mNextQidToFree(0),
	mFdoConnection( connection ), // no addref as it is owned by a component that is already holding a reference on the connection. 
	mInsertAutoIncrementProperties( false ),
	mBindUnsetValues( true )
{
    memset( mInsertQueryCache, 0, sizeof(InsertQueryDef)*QUERY_CACHE_SIZE );
    mLastTableName[0] = '\0';
    for( int i = 0; i<QUERY_CACHE_SIZE; i++ )
        mInsertQueryCache[i].qid = -1;
}

FdoRdbmsPvcInsertHandler::~FdoRdbmsPvcInsertHandler()
{
	DbiConnection *mConnection = mFdoConnection->GetDbiConnection();
	for( int i = 0; i<QUERY_CACHE_SIZE; i++ )
    {
        if (mInsertQueryCache[i].qid != -1 && mFdoConnection->GetConnectionState() == FdoConnectionState_Open )
		{
            mConnection->GetGdbiCommands()->free_cursor(mInsertQueryCache[i].qid);
			mInsertQueryCache[i].qid = -1;
		}
        if (mInsertQueryCache[i].bind != NULL)
        {
            for (int j=0; j<mInsertQueryCache[i].count; j++)
            {
                if (NULL != mInsertQueryCache[i].bind[j].value.strvalue)
                    // the BLOB value was not allocated
                    if (mInsertQueryCache[i].bind[j].type != FdoDataType_BLOB)
                        if (mInsertQueryCache[i].bind[j].type == FdoRdbmsDataType_Geometry)
						{
                            ((FdoIGeometry*)mInsertQueryCache[i].bind[j].value.strvalue)->Release ();
							mInsertQueryCache[i].bind[j].value.strvalue = NULL;
						}
                        else if( mInsertQueryCache[i].bind[j].valueNeedsFree )
						{
							delete[] (char*)mInsertQueryCache[i].bind[j].value.strvalue;
							mInsertQueryCache[i].bind[j].value.strvalue = NULL;
							mInsertQueryCache[i].bind[j].valueNeedsFree = false;
						}
            }
            delete [] mInsertQueryCache[i].bind;
			mInsertQueryCache[i].bind = NULL;
        }
    }
}

long FdoRdbmsPvcInsertHandler::Execute( const FdoSmLpClassDefinition *classDefinition, FdoPropertyValueCollection  *propValCollection, bool revisionNumUpdate, bool handleForeignAutoincrementedId )
{
	int                 i;
    int                 gid = -1;
    int                 numberOfProperties;
    FdoRdbmsPvcBindDef  *bind = NULL;
    InsertQueryDef      *insertQuery = NULL;

	DbiConnection *mConnection = mFdoConnection->GetDbiConnection();

    try
    {
        if (propValCollection == NULL)
            return 0;

        numberOfProperties = (int) propValCollection->GetCount();
        if (numberOfProperties == 0)
            return 0;

        // Only the main class may have a list that ONLY contain system or autogenerated properties. In that case
        // and when all other properties are nullable properties, we are creating an empty object.
        // The object property classes attached to the main object cannot contain only system and autogen properties;
        // it means the user did not provide any values for those sub-object and we will not add any empty objects.
		// Unless we are overrriding autoincrement property, then all bets are off.
		if( dynamic_cast<const FdoSmLpObjectPropertyClass*>(classDefinition) != NULL && ! mInsertAutoIncrementProperties )
        {
            const FdoSmLpPropertyDefinitionCollection *properties = classDefinition->RefProperties();
            bool emptyPropList = true;
            for( i=0; i<numberOfProperties; i++ )
            {
                FdoPtr<FdoPropertyValue> prop = propValCollection->GetItem(i);
                FdoPtr<FdoIdentifier>nameId = prop->GetName();
                const FdoSmLpPropertyDefinition *phprop = properties->RefItem( nameId->GetName() );
                if( phprop && phprop->GetPropertyType() == FdoPropertyType_DataProperty )
                {
                    const FdoSmLpDataPropertyDefinition *dataProp = (FdoSmLpDataPropertyDefinition *)phprop;
                    if( ! dataProp->GetIsAutoGenerated() &&
                        ! dataProp->GetIsSystem() &&
                        ! dataProp->GetIsFeatId() )
                    {
                        // Check if it's an autogenerated property; the autogenerated property is the property added by schema
                        // manager for Object properties
                        const FdoSmLpObjectPropertyClass* cls = dynamic_cast<const FdoSmLpObjectPropertyClass*>(classDefinition);
                        if( cls )
                        {
                            const FdoSmLpDataPropertyDefinitionCollection *targProps = cls->RefTargetProperties();
                            const FdoSmLpDataPropertyDefinition *targProp = targProps->RefItem( nameId->GetName() );
                            if( targProp == NULL )
                            {
                                emptyPropList = false;
                                break;
                            }
                        }
                    }
                }
            }
            if( emptyPropList )
                return 0;
        }
        const FdoSmLpDbObject* table = classDefinition->RefDbObject();
        FdoStringP tableName = table->RefDbObject()->GetDbQName();

        const wchar_t *name = classDefinition->GetName();
		if( mInsertAutoIncrementProperties )
			insertQuery = GetInsertQuery( (const wchar_t*)(FdoStringP(name,true)+FdoStringP(L"WithId")), true );
		else
			insertQuery = GetInsertQuery(  name, false );

		FdoStringP valuesString(L"");
        FdoStringP colSpecString(L"");
		FdoStringP insertStartString(L"");
		FdoStringP whereString(L"");
		int bindCount = 0;
        // Reparse each time in the LOBs are involved
        // (the insert stm. may be different depending on the current values)
        if(insertQuery->qid != -1 && !FdoRdbmsLobUtility::ContainsLobs( classDefinition ) )
        {
            // CreateInsertString may modify the propValCollection in case of adding association.
            CreateInsertString( classDefinition, propValCollection, colSpecString, valuesString, bindCount, true);
            bind = insertQuery->bind;
        }
        else
        {			
            CreateInsertString( classDefinition, propValCollection, colSpecString, valuesString, bindCount, false);

            bool useLocalInsertString = true;
            const FdoSmLpDataPropertyDefinitionCollection *propDefCol = classDefinition->RefIdentityProperties();
            for( int i = 0; i < propDefCol->GetCount(); i++ )
            {
                if( propDefCol->RefItem(i)->GetIsAutoGenerated() )
                {
                    useLocalInsertString = false;
                    break;
                }
            }

            if( useLocalInsertString && ( classDefinition->GetClassType() == FdoClassType_FeatureClass ) )
            {
                FdoIdentifier *currPropName = NULL;
	            const FdoSmLpPropertyDefinitionCollection *allProps = classDefinition->RefProperties();

	            for( int i = 0; i < propValCollection->GetCount(); i++ )
	            {
                    currPropName = propValCollection->GetItem(i)->GetName();
		            const FdoSmLpDataPropertyDefinition *aProp =
                        FdoSmLpDataPropertyDefinition::Cast(allProps->RefItem(currPropName->GetName()));
                    if ( aProp != NULL )
                    {
		                if( aProp->GetIsAutoGenerated() )
		                {
			                useLocalInsertString = false;
		                }
                    }
                    currPropName->Release();
                    currPropName = NULL;
                    if( !useLocalInsertString )
                        break;
                }
            }

            if( useLocalInsertString )
                FdoRdbmsPvcInsertHandler::GetStartInsertString( insertStartString, tableName );
            else
                GetStartInsertString( insertStartString, tableName );

			CreateInsertStringWhereCriteria( classDefinition, propValCollection, whereString, bindCount );

            FdoStringP tmp = FdoStringP::Format(L"%ls %ls %ls %ls",
													(const wchar_t * ) insertStartString,
                                                    (const wchar_t * ) colSpecString,
                                                    (const wchar_t * ) valuesString,
													(const wchar_t * ) whereString);

            mConnection->GetGdbiCommands()->sql( (wchar_t *)(const wchar_t *) tmp, &gid );

            // setup bind variables
            bind = new FdoRdbmsPvcBindDef[bindCount];
            if (!bind)
                throw FdoCommandException::Create(NlsMsgGet(FDORDBMS_11, "Memory error"));
            memset (bind, 0, sizeof(FdoRdbmsPvcBindDef) * bindCount);
            int bind_no = 0;
            SetBindVariables(classDefinition, L"", bind_no, propValCollection, bind, gid);
			
			SetAditionalBindVariables(classDefinition, L"", bind_no, propValCollection, bind, gid);

            insertQuery->bind = bind;
            insertQuery->qid = gid;
            insertQuery->count = bindCount;
        }

        for (i=0; i<insertQuery->count; i++)
        {
            if (bind[i].type == FdoRdbmsDataType_Geometry)
            {
                if (NULL != bind[i].value.strvalue)
                    ((FdoIGeometry*)bind[i].value.strvalue)->Release ();
                bind[i].value.strvalue = NULL;
            }
			else if (bind[i].type != FdoDataType_BLOB && bind[i].type != FdoDataType_String && bind[i].value.strvalue )
                memset(bind[i].value.strvalue, 0, bind[i].len );

            mConnection->GetGdbiCommands()->set_null( &bind[i].null_ind, 0, 0 );
        }

        SetBindValues(classDefinition, propValCollection, insertQuery, handleForeignAutoincrementedId);

        mConnection->GetGdbiCommands()->execute( insertQuery->qid );

        // Insert LOB values Stream Reader based
//        FdoRdbmsLobUtility::InsertStreamedLobs( mConnection, classDefinition, propValCollection, insertQuery->bind, insertQuery->count );

    }
    catch( ... )
    {
        if( insertQuery != NULL && insertQuery->qid != -1 )
        {
            mConnection->GetGdbiCommands()->free_cursor( insertQuery->qid );
            insertQuery->qid = -1;
            delete [] insertQuery->bind;
            insertQuery->bind = NULL;
        }

        throw;
    }

	return 1;
}



void FdoRdbmsPvcInsertHandler::CreateInsertString(const FdoSmLpClassDefinition *currentClass,
                                               FdoPropertyValueCollection  *propValCollection,
                                               FdoStringP& insertString,
                                               FdoStringP& valuesString,
                                               int& bindCount,
                                               bool scanOnly )
{
    const   FdoSmLpPropertyDefinitionCollection *propertyDefinitions = currentClass->RefProperties();
    int     i;
    bool    emptyBlobAdded;

    FdoStringP comma(L",");

	DbiConnection *mConnection = mFdoConnection->GetDbiConnection();

    const FdoSmPhDbObject* classTab = currentClass->RefDbObject()->RefDbObject();
    for (i=0; i<propertyDefinitions->GetCount(); i++)
    {
        const FdoSmLpPropertyDefinition *propertyDefinition = propertyDefinitions->RefItem(i);
        FdoPropertyType  propType = propertyDefinition->GetPropertyType();
        emptyBlobAdded = false;
        const wchar_t* tmpName = propertyDefinition->GetName();
        switch ( propType )
        {
            case FdoPropertyType_DataProperty:
                {
                    if( scanOnly )
                        break;

                    const FdoSmLpSimplePropertyDefinition* simpleProp =
                        static_cast<const FdoSmLpSimplePropertyDefinition*>(propertyDefinition);

                    const FdoSmLpDataPropertyDefinition* dataProp =
                        static_cast<const FdoSmLpDataPropertyDefinition*>(propertyDefinition);

                    bool autoGenerated = dataProp && dataProp->GetIsAutoGenerated();

                    if( simpleProp->RefContainingDbObject() != classTab )
                        continue;

                    // We update feat id even though it's a system column.
                    // We update read-only properties only if they are autogenerated.
                //  if ( (simpleProp->RefIsSystem() == true ||
                //          (simpleProp->RefReadOnly() == true && autoGenerated == false)) &&
                //         simpleProp->RefIsFeatId() == false )
                //      continue;

                    const FdoSmPhColumn *column = simpleProp->RefColumn();
                    if( column == NULL || ( ! mInsertAutoIncrementProperties && column->GetAutoincrement() ) )
                        continue;

                    CreateInsertStringForColumn(
                        column,
                        propertyDefinition,
                        propValCollection,
                        insertString, valuesString,
                        bindCount, emptyBlobAdded );
                }
                break;

            case FdoPropertyType_GeometricProperty:
                {
                    if( scanOnly )
                        break;

                    const FdoSmLpSimplePropertyDefinition* simpleProp =
                        static_cast<const FdoSmLpSimplePropertyDefinition*>(propertyDefinition);

                    if( simpleProp->RefContainingDbObject() != classTab )
                        continue;

                    const FdoSmLpGeometricPropertyDefinition* geomProp =
                        static_cast<const FdoSmLpGeometricPropertyDefinition*>(propertyDefinition);
                    FdoSmOvGeometricColumnType columnType = geomProp->GetGeometricColumnType();

                    switch (columnType)
                    {
                    case FdoSmOvGeometricColumnType_Default:
                    case FdoSmOvGeometricColumnType_BuiltIn:
                    case FdoSmOvGeometricColumnType_Blob:
                    case FdoSmOvGeometricColumnType_Clob:
                    case FdoSmOvGeometricColumnType_String:
                        {
                            const FdoSmPhColumn *column = simpleProp->RefColumn();
                            if (NULL != column)
                            {
                                CreateInsertStringForColumn(
                                    column,
                                    propertyDefinition,
                                    propValCollection,
                                    insertString, valuesString,
                                    bindCount, emptyBlobAdded );
                            }
                        }
                        break;
                    case FdoSmOvGeometricColumnType_Double:
                        {
                            const FdoSmPhColumn *columnX = geomProp->RefColumnX();
                            const FdoSmPhColumn *columnY = geomProp->RefColumnY();
                            const FdoSmPhColumn *columnZ = geomProp->RefColumnZ();

                            if (NULL != columnX && NULL != columnY)
                            {
                                // Support ordinate column storage format.
                                CreateInsertStringForColumn(
                                    columnX,
                                    propertyDefinition,
                                    propValCollection,
                                    insertString, valuesString,
                                    bindCount, emptyBlobAdded );
                                CreateInsertStringForColumn(
                                    columnY,
                                    propertyDefinition,
                                    propValCollection,
                                    insertString, valuesString,
                                    bindCount, emptyBlobAdded );
                                if (NULL != columnZ)
                                {
                                    CreateInsertStringForColumn(
                                        columnZ,
                                        propertyDefinition,
                                        propValCollection,
                                        insertString, valuesString,
                                        bindCount, emptyBlobAdded );
                                }
                            }
                        }
                        break;
                    default:
                        // Nothing useful to do here.
                        continue;
                    }   // end of switch (columnType)

                    // Support spatial index columns, if present.
                    const FdoSmPhColumn *columnSi1 = geomProp->RefColumnSi1();
                    const FdoSmPhColumn *columnSi2 = geomProp->RefColumnSi2();
                    if (NULL != columnSi1 && NULL != columnSi2)
                    {
                        CreateInsertStringForColumn(
                            columnSi1,
                            propertyDefinition,
                            propValCollection,
                            insertString, valuesString,
                            bindCount, emptyBlobAdded );

                        CreateInsertStringForColumn(
                            columnSi2,
                            propertyDefinition,
                            propValCollection,
                            insertString, valuesString,
                            bindCount, emptyBlobAdded );
                    }
                }
                break;

            case FdoPropertyType_ObjectProperty:
                {
                    const FdoSmLpObjectPropertyDefinition* objProp = static_cast<const FdoSmLpObjectPropertyDefinition*>(propertyDefinition);
                    const FdoSmLpPropertyMappingDefinition* mappping = objProp->RefMappingDefinition();
                    if ( mappping->GetType() != FdoSmLpPropertyMappingType_Single )
                        break; // We only handle the single mapping

                    const FdoSmLpPropertyMappingSingle * singleMapping = static_cast<const FdoSmLpPropertyMappingSingle*>( mappping );
                    CreateInsertString( objProp->RefTargetClass(), propValCollection, insertString, valuesString, bindCount, scanOnly );
                }
                break;

            case FdoPropertyType_AssociationProperty:
                {
                    const FdoSmLpAssociationPropertyDefinition* associationPropertyDefinition = static_cast<const FdoSmLpAssociationPropertyDefinition*>(propertyDefinition);
                    if( associationPropertyDefinition->GetReadOnly() )
                    {
                        // TODO: need to check the property value collection and not the class properties.

                        // Should not happen as we don't add the read-only association property.
                        // The caller must have added it to the collection.
                        //throw FdoCommandException::Create(NlsMsgGet(FDORDBMS_290, "Cannot set a read only association property"));
                        break;
                    }


                    //
                    // We only add the column if the identity properties are not set; translation: we added axtra column
                    // to link to the associated class. If the identity properties are set, it mean we are using existing
                    // properties/column and there is no need to add any column as those column will be added a data properties.
                    const FdoStringsP   identCollection = associationPropertyDefinition->GetIdentityProperties();
                    if( identCollection->GetCount() == 0  )
                    {
                        const FdoSmPhColumnListP identCols  = associationPropertyDefinition->GetReverseIdentityColumns();
                        for(int i=0; i<identCols->GetCount() && ! scanOnly ; i++ )
                        {
							CreateInsertStringForColumn(
								(const wchar_t * ) identCols->GetDbString(i),
								insertString, valuesString,
								bindCount );
                        }
                    }
                    else
                    {
                        //
                        // We may have duplicate entry for the same column. The <asso>.<ident> or the rever_ident property may both be initialized.
                        // If both are initialized, then both values should be the same.
                        // If only the <asso>.<ident> is set, then we (add) and/or set the rever_ident property.
                        // If the rever_ident is set, then we do nothing
                        const FdoStringsP   revIdentCollection = associationPropertyDefinition->GetReverseIdentityProperties();
                        for( int i=0; i<identCollection->GetCount(); i++ )
                        {
                            FdoStringP assoPropName = FdoStringP::Format(L"%ls.%ls",propertyDefinition->GetName(),(const wchar_t*)(identCollection->GetString(i)));
                            FdoPtr<FdoPropertyValue> assocPropertyValue;
                            FdoPtr<FdoPropertyValue> identPropertyValue;
                            FdoPtr<FdoValueExpression> assoVal;
                            FdoPtr<FdoValueExpression> identVal;
                            assocPropertyValue = propValCollection->FindItem( (const wchar_t*)assoPropName );
                            assoVal = assocPropertyValue ? assocPropertyValue->GetValue() : NULL;

                            FdoStringP  revIdenName = revIdentCollection->GetString(i);
                            identPropertyValue = propValCollection->FindItem( (const wchar_t*)(revIdenName) );
                            identVal = identPropertyValue ? identPropertyValue->GetValue() : NULL;
                            if( assocPropertyValue != NULL && identPropertyValue != NULL &&  assoVal != NULL && identVal != NULL )
                            {
                                if( FdoRdbmsUtil::StrCmp(assoVal->ToString(), identVal->ToString() ) )
                                    throw FdoCommandException::Create(NlsMsgGet2(FDORDBMS_291, "Association property '%1$ls' and property '%2$ls' must have the same value or only one should be set",
                                    (const wchar_t*)assoPropName, (const wchar_t*)revIdenName ));

                            }
                            else if( assoVal != NULL )
                            {
                                if( identPropertyValue != NULL )
                                {
                                    // rever ident found but not set; set its value from the <asso>.<ident> property value.
                                    // Note that this may not get executed as this property will be removed in FdoRdbmsSchemaUtil::GroupByClass
                                    identPropertyValue->SetValue( assoVal );
                                }
                                else
                                {
                                    // The <asso>.<ident> is set and the rever_ident does not exist. In this case we just
                                    // rename the <asso>.<ident> name to the rever_ident name. The correponding column is already
                                    // by the data property case above. We only needed to hook the value of the property. That is
                                    // easily done by renaming the property that contain the value to the name of the property
                                    // that need the value.
                                    assocPropertyValue->SetName( (const wchar_t*)revIdenName );
                                }
                            }
                        }
                    }
                    //
                    // Perform a constrain check before goind any further. The constrain check should be done at this point as it
                    // depend on the processing that may happen above.
                    AssociationConstrainCheck( associationPropertyDefinition, propValCollection );
                }
                break;
            default:
                break;
        }
    }

}

void FdoRdbmsPvcInsertHandler::GetStartInsertString( FdoStringP& insertStartString, const wchar_t* tableName )
{
	const wchar_t* frmStr = L"insert into %ls ";
	insertStartString = FdoStringP::Format(frmStr, tableName );
}

void FdoRdbmsPvcInsertHandler::CreateInsertStringWhereCriteria(
        const FdoSmLpClassDefinition *classDefinition,
        FdoPropertyValueCollection  *propValCollection,
        FdoStringP &whereString,
        int& bindCount )
{
		whereString = ")"; // Needed to close the values spec
}

void FdoRdbmsPvcInsertHandler::CreateInsertStringForColumn(
        const wchar_t *columnName,
        FdoStringP &insertString,
        FdoStringP &valuesString,
        int& bindCount )
{
	FdoStringP comma(L",");

	if( ((const wchar_t*)valuesString)[0] == '\0' )
		valuesString += L") values ("; // End of the column spec and start of values spec

	if( ((const wchar_t*)insertString)[0] == '\0' )
		insertString += L" (";  // Start of the columns spec

    if( bindCount != 0 )
        insertString += (const wchar_t * )comma;
    insertString += (const wchar_t * ) columnName;

    if( bindCount != 0 )
        valuesString += (const wchar_t * )comma;

    valuesString += mFdoConnection->GetBindString( bindCount+1 );
    
	bindCount++;
}

void FdoRdbmsPvcInsertHandler::CreateInsertStringForColumn(
    const FdoSmPhColumn *column,
    const FdoSmLpPropertyDefinition *propertyDefinition,
    FdoPropertyValueCollection  *propValCollection,
    FdoStringP &insertString,
    FdoStringP &valuesString,
    int& bindCount,
    bool& emptyBlobAdded )
{
    FdoStringP comma(L",");
    FdoStringP empty_blob(L"EMPTY_BLOB()");
    FdoStringP null_blob(L"NULL");

	if( ((const wchar_t*)valuesString)[0] == '\0' )
		valuesString += L") values ("; // End of the column spec and start of values spec

	if( ((const wchar_t*)insertString)[0] == '\0' )
		insertString += L" (";  // Start of the columns spec

    FdoStringP colName = column->GetDbName();
    if( bindCount != 0 )
        insertString += (const wchar_t * )comma;
    insertString += (const wchar_t * ) colName;

    if( bindCount != 0 )
        valuesString += (const wchar_t * )comma;

    // We'll bind LOB references in separate SELECT operation.
    // Insert an empty lob if inserting is streamed.
    FdoPtr<FdoPropertyValue> propertyValue;
    FdoPtr<FdoIStreamReader> streamReader;

    propertyValue = propValCollection->FindItem( propertyDefinition->GetName() );
    if ( propertyValue )
        streamReader = propertyValue->GetStreamReader();

    FdoPropertyType  propType = propertyDefinition->GetPropertyType();

    if (propType == FdoPropertyType_DataProperty)
    {
        const FdoSmLpDataPropertyDefinition* dataProp =
        static_cast<const FdoSmLpDataPropertyDefinition*>(propertyDefinition);

        if ( dataProp->GetDataType() == FdoDataType_BLOB )
        {
            emptyBlobAdded = true;
            if ( streamReader != NULL )
                valuesString += (const wchar_t * )empty_blob;
            else if ( propertyValue == NULL || propertyValue->GetValue() == NULL )
                valuesString += (const wchar_t * )null_blob;
            else
                emptyBlobAdded = false;
        }
    }
    if ( !emptyBlobAdded )
    {
        valuesString += mFdoConnection->GetBindString( bindCount+1 );
    }
    bindCount++;
}

void FdoRdbmsPvcInsertHandler::SetBindValues(const FdoSmLpClassDefinition *classDefinition, 
											 FdoPropertyValueCollection  *propValCollection, InsertQueryDef *insertQuery,
                                             bool handleForeignAutoincrementedId)
{
    int                 i;
    int                 j;
    FdoPtr<FdoPropertyValue> propertyValue;
    FdoRdbmsPvcBindDef *bind = insertQuery->bind;

	DbiConnection *mConnection = mFdoConnection->GetDbiConnection();
    FdoRdbmsSpatialManagerP spatialManager = mFdoConnection->GetSpatialManager();

	// Determine if the id property is autoincremented
	bool featIdAutoincremented = false;
    const FdoSmLpPropertyDefinition *featIdProp = classDefinition->RefFeatIdProperty();
	if ( featIdProp ) 
	{
		const FdoSmLpSimplePropertyDefinition* simpleProp =
			static_cast<const FdoSmLpSimplePropertyDefinition*>(featIdProp);

		const FdoSmPhColumn *column = simpleProp->RefColumn();
		featIdAutoincremented = (column && column->GetAutoincrement() );
	}
	
    for (i=0; i<propValCollection->GetCount(); i++)
    {
        bool   isAssociation = false;

        propertyValue = propValCollection->GetItem(i);
        if (propertyValue == NULL)
            throw FdoCommandException::Create(NlsMsgGet(FDORDBMS_39, "Property value is NULL"));
        FdoPtr<FdoIdentifier>identifier = propertyValue->GetName();

        const FdoSmPhColumn *columnDef = NULL;
        if (handleForeignAutoincrementedId)
        {
            const FdoSmLpPropertyDefinitionCollection * propertyDefs = classDefinition->RefProperties();
            const FdoSmLpPropertyDefinition * propertyDef = propertyDefs->RefItem(identifier->GetName());
            FdoPropertyType propertyDefType = propertyDef->GetPropertyType();
            if (FdoPropertyType_DataProperty == propertyDefType)
            {
		        const FdoSmLpSimplePropertyDefinition* simplePropDef =
			        static_cast<const FdoSmLpSimplePropertyDefinition*>(propertyDef);
                if ( simplePropDef != NULL )
                    columnDef = simplePropDef->RefColumn();
            }
        }

        // Nothing to do if FeatId column is autoincremented
        if( ! mInsertAutoIncrementProperties && featIdAutoincremented && wcscmp( featIdProp->GetName(), identifier->GetText() ) == 0 )
            continue;
        // Same for other autogenerated properties.
        else if( handleForeignAutoincrementedId && ! mInsertAutoIncrementProperties && columnDef && columnDef->GetAutoincrement() )
            continue;

        //
        // Only association properties will end up in the property value collection with composite names as <prop1>.<prop2>
        int length;
        if( identifier->GetScope( length ) && length == 1 )
            isAssociation = true;

        const wchar_t* name  = identifier->GetText();
        for (j=i+1; j<propValCollection->GetCount(); j++)
        {
            FdoPtr<FdoPropertyValue> propertyValue2 = propValCollection->GetItem(j);
            if (!propertyValue2 )
                throw FdoCommandException::Create(NlsMsgGet(FDORDBMS_39, "Property value is NULL"));
            FdoPtr<FdoIdentifier> identifier = propertyValue2->GetName();
            if (wcscmp(name, identifier->GetText()) == 0)
                break;
        }
        if (j < propValCollection->GetCount())
            continue;

        FdoPtr<FdoValueExpression> literal = propertyValue->GetValue();
        FdoPtr<FdoIStreamReader> stream = propertyValue->GetStreamReader();

        if (literal == NULL && stream == NULL)
            continue;  // TODO: Should this be an Exception?

        FdoDataValue *dataValue = NULL;
        FdoGeometryValue *geomValue = NULL;

        if (literal != NULL)
        {
            dataValue = (dynamic_cast<FdoDataValue*>(literal.p));
            geomValue = (dynamic_cast<FdoGeometryValue*>(literal.p));

            if ( (dataValue && dataValue->IsNull()) || (geomValue && geomValue->IsNull()))
                continue;
        }

        // We'll need the property definition and possibly spatial index values for geometries.
        FdoStringsP geomSiKeys;
        FdoInt32 geomBindIndex = -1;
        const FdoSmLpGeometricPropertyDefinition * geomPropDef = NULL;
        if (NULL != geomValue)
        {
            const FdoSmLpPropertyDefinitionCollection * propertyDefs = classDefinition->RefProperties();
            const FdoSmLpPropertyDefinition * propertyDef = propertyDefs->RefItem(identifier->GetName());
            if ( propertyDef == NULL )
                throw FdoException::Create(FdoException::NLSGetMessage(FDO_NLSID(FDO_2_BADPARAMETER)));
            if ( FdoPropertyType_GeometricProperty != propertyDef->GetPropertyType() )
                throw FdoException::Create(FdoException::NLSGetMessage(FDO_NLSID(FDO_2_BADPARAMETER)));

            geomPropDef = static_cast<const FdoSmLpGeometricPropertyDefinition *>(propertyDef);
        }

        bool foundColumn = false;

        for (j=0; j< insertQuery->count; j++)
        {
            if (wcscmp(name, bind[j].propertyName) == 0)
            {
                mConnection->GetGdbiCommands()->set_nnull( &bind[j].null_ind, 0, 0 );

                if (bind[j].type == FdoRdbmsDataType_Geometry) {

                    FdoFgfGeometryFactory * gf = FdoFgfGeometryFactory::GetInstance();
                    FdoByteArray        *ba = geomValue->GetGeometry();
                    FdoIGeometry	*newGeomValue = NULL;
                    if ( ba )
                    {
                        mConnection->GetSchemaUtil()->SetActiveSpatialContext( classDefinition, name );

                        newGeomValue = gf->CreateGeometryFromFgf( ba );

                        mConnection->GetSchemaUtil()->CheckGeomPropOrdDimensionality( classDefinition, name, newGeomValue );
                        mConnection->GetSchemaUtil()->CheckGeomPropShapeDimensionality( classDefinition, name, newGeomValue );
                        mConnection->GetSchemaUtil()->CheckGeomPropValidity( classDefinition, name, newGeomValue );

                        // Compute the SI key values.
                        const FdoSmPhColumn *columnSi1 = geomPropDef->RefColumnSi1();
                        const FdoSmPhColumn *columnSi2 = geomPropDef->RefColumnSi2();
                        if (NULL != columnSi1 && NULL != columnSi2 && spatialManager != NULL )
                        {
                            spatialManager->InsertGeometryInLine(geomPropDef, geomValue, geomSiKeys);
                            geomBindIndex = j;
                        }
                    }
                    else
                        mConnection->GetGdbiCommands()->set_null( &bind[j].null_ind, 0, 0 );

                    FdoIGeometry *oldGeomValue = (FdoIGeometry*) bind[j].value.strvalue;
                    FDO_SAFE_RELEASE( oldGeomValue );
                    bind[j].value.strvalue = (char*) newGeomValue;
                    FDO_SAFE_RELEASE( ba );
                    FDO_SAFE_RELEASE( gf );
                    foundColumn = true;
                    break;
                }
                else if (NULL != geomValue)
                {
                    // The property value is a geometry, but the column isn't geometric.
                    // Check for a match against SI columns and non-built-in geometric
                    // column storage formats.
                    FdoString * columnNameSi1 = geomPropDef->GetColumnNameSi1();
                    FdoString * columnNameSi2 = geomPropDef->GetColumnNameSi2();
                    if (wcscmp(columnNameSi1, bind[j].name) == 0 ||
                        wcscmp(columnNameSi2, bind[j].name) == 0)
                    {
                        ;   // Nothing to do here; SI values are handled separately, below.
                    }
                    else
                    {
                        FdoPtr<FdoByteArray>    ba = geomValue->GetGeometry();
                        if (ba == NULL)
                            continue;

                        FdoPtr<FdoFgfGeometryFactory> gf = FdoFgfGeometryFactory::GetInstance();
                        FdoPtr<FdoIGeometry>    geomValue = gf->CreateGeometryFromFgf( ba );
                        FdoGeometryType         geomType = geomValue->GetDerivedType();

                        FdoSmOvGeometricColumnType columnType = geomPropDef->GetGeometricColumnType();

                        if (FdoSmOvGeometricColumnType_Double == columnType)
                        {
                            if (FdoGeometryType_Point != geomType)
                                continue;
                            FdoIPoint * pointValue = static_cast<FdoIPoint *>(geomValue.p);
                            

                            const FdoSmPhColumn *columnX = geomPropDef->RefColumnX();
                            const FdoSmPhColumn *columnY = geomPropDef->RefColumnY();
                            const FdoSmPhColumn *columnZ = geomPropDef->RefColumnZ();
                            double x, y, z, m;
                            FdoInt32 dimensionality;
                            double doubleValue = 0.0;

                            pointValue->GetPositionByMembers(&x, &y, &z, &m, &dimensionality);

                            if (NULL != columnX && wcscmp(columnX->GetName(), bind[j].name)==0)
                                doubleValue = x;
                            else if (NULL != columnY && wcscmp(columnY->GetName(), bind[j].name)==0)
                                doubleValue = y;
                            else if (NULL != columnZ && wcscmp(columnZ->GetName(), bind[j].name)==0)
                                doubleValue = z;
                            else
                                continue;

                            sprintf((char*)bind[j].value.strvalue, "%.16g", doubleValue);
                        }
                    }
                    foundColumn = true;
                    continue;
                }
                else if (NULL == geomValue)
                {
                    // FdoDataType_BLOB by ref. have NULL dataValue
                    int dataType = dataValue ? dataValue->GetDataType() : bind[j].type;
                    // get the scale value for DOUBLE/DECIMAL types
                    const FdoSmLpPropertyDefinitionCollection * propertyDefs = classDefinition->RefProperties();
                    const FdoSmLpPropertyDefinition * propertyDef = propertyDefs->RefItem(bind[j].propertyName);
                    const FdoSmLpSimplePropertyDefinition* simplePropDef =
                        static_cast<const FdoSmLpSimplePropertyDefinition*>(propertyDef);

                    int scale = -100; // -100 is not a valid scale value
                    if (simplePropDef != NULL)
                    {
                        const FdoSmPhColumn *columnDef = simplePropDef->RefColumn();
                        if (columnDef)
                            scale = columnDef->GetScale();
                    }

                    switch ( dataType )   {
                        case FdoDataType_Boolean:
                            {
                                bool boolValue = (static_cast<FdoBooleanValue*>(dataValue))->GetBoolean();
                                sprintf((char*)bind[j].value.strvalue, "%d", boolValue);
                            }
                            break;
                        case FdoDataType_Byte:
                            {
                                FdoByte byteValue = (static_cast<FdoByteValue*>(dataValue))->GetByte();
                                sprintf((char*)bind[j].value.strvalue, "%d", byteValue);
                            }
                            break;

                        case FdoDataType_DateTime:
                            const char *timeValue;
                            {
                                FdoDateTime dateTime;
                                dateTime = (static_cast<FdoDateTimeValue*>(dataValue))->GetDateTime();
                                timeValue = mFdoConnection->FdoToDbiTime(dateTime);
                            }
                            strcpy((char*)bind[j].value.strvalue, timeValue);
                            break;

                        case FdoDataType_Decimal:
                            {
                                double decimalValue = (static_cast<FdoDecimalValue*>(dataValue))->GetDecimal();
                                sprintf((char*)bind[j].value.strvalue, "%.*f", (scale != -100) ? scale : 8, decimalValue);
                            }
                            break;

                        case FdoDataType_Double:
                            {
                                double doubleValue = (static_cast<FdoDoubleValue*>(dataValue))->GetDouble();
                                sprintf((char*)bind[j].value.strvalue, "%.16g", doubleValue);
                            }
                            break;

                        case FdoDataType_Int16:
                            {
                                FdoInt16 int16Value = (static_cast<FdoInt16Value*>(dataValue))->GetInt16();
                                sprintf((char*)bind[j].value.strvalue, "%d", int16Value);
                            }
                            break;

                        case FdoDataType_Int32:
                            {
                                // We should accept any int value precision (32,16)
                                FdoInt32 int32Value;
                                if( dataValue->GetDataType() == FdoDataType_Int16 )
                                    int32Value = (static_cast<FdoInt16Value*>(dataValue))->GetInt16();
                                else if ( dataValue->GetDataType() == FdoDataType_Int32 )
                                    int32Value = (static_cast<FdoInt32Value*>(dataValue))->GetInt32();
                                else
                                    throw FdoCommandException::Create(NlsMsgGet1(FDORDBMS_293, "Property type and value type mismatch for property %1$ls", name));

                                sprintf((char*)bind[j].value.strvalue, "%d", int32Value);
                            }
                            break;

                        case FdoDataType_Int64:
                            {
                                // We should accept any int value precision (32,16)
                                FdoInt64   val;
                                if( dataValue->GetDataType() == FdoDataType_Int16 )
                                    val = (static_cast<FdoInt16Value*>(dataValue))->GetInt16();
                                else if ( dataValue->GetDataType() == FdoDataType_Int32 )
                                    val = (static_cast<FdoInt32Value*>(dataValue))->GetInt32();
                                else if ( dataValue->GetDataType() == FdoDataType_Int64 )
                                    val = (static_cast<FdoInt64Value*>(dataValue))->GetInt64();
                                else
                                    throw FdoCommandException::Create(NlsMsgGet1(FDORDBMS_293, "Property type and value type mismatch for property %1$ls", name));
#ifdef _WIN32
                                _i64toa( val,(char*)bind[j].value.strvalue, 10 );
#else
                                sprintf((char*)bind[j].value.strvalue, "%lld", val);
#endif
                            }
                            break;

                        case FdoDataType_Single:
                            {
                                float singleValue = (static_cast<FdoSingleValue*>(dataValue))->GetSingle();
                                sprintf((char*)bind[j].value.strvalue, "%.*f", (scale != -100) ? scale : 8, singleValue);
                            }
                            break;

                        case FdoDataType_String:
                            {
                                const wchar_t *wcharValue;
                                wcharValue = (static_cast<FdoStringValue*>(dataValue))->GetString();
								if( bind[j].type == FdoDataType_String && mConnection->GetGdbiCommands()->SupportsUnicode() )
								{
									wcsncpy((wchar_t*)bind[j].value.strvalue, wcharValue, bind[j].len);
									((wchar_t*)bind[j].value.strvalue)[bind[j].len-1] = '\0';
								}
								else
								{
									FdoStringP  str = wcharValue;
									const char* charVal = (const char*)str;
									strncpy((char*)bind[j].value.strvalue, charVal, bind[j].len);
									((char*)bind[j].value.strvalue)[bind[j].len-1] = '\0';
								}
                            }
                            break;

                        case FdoDataType_BLOB:
                            {
                                char temp[32];
                                sprintf(temp, "%d", j+1);

                                if ( stream != NULL )
                                {
                                    bind[j].value.strvalue = NULL;  // Oracle will return a LOB locator
                                    bind[j].len = sizeof(void *);
                                    bind[j].reader = stream;
                                }
                                else
                                {
                                    // Avoid copying the value by using directly the address of data
                                    FdoBLOBValue * blob = static_cast<FdoBLOBValue*>(dataValue);

                                    FdoByteArray * byteArr = blob->GetData();
                                    bind[j].value.strvalue = (char*) byteArr->GetData();
                                    bind[j].len = byteArr->GetCount();

                                    mConnection->GetGdbiCommands()->bind(insertQuery->qid, temp, RDBI_BLOB, bind[j].len,
                                                        (char*)bind[j].value.strvalue, &bind[j].null_ind );
                                }
                            }
                            break;

                        default:
                            throw FdoCommandException::Create(NlsMsgGet1(FDORDBMS_54, "Unhandled type: %1$d", bind[j].type));
                            break;
                    }
                    foundColumn = true;
                    break;
                }
            }
        }

        if (!foundColumn && ! isAssociation )
            throw FdoCommandException::Create(NlsMsgGet1(FDORDBMS_56, "Property '%1$ls' not found", name ));

        // Assign SI key values to bind buffers.
        if (NULL != geomValue && geomBindIndex >= 0 && geomSiKeys->GetCount() > 0)
        {
            // Rather than scanning the array of bind values again, assume that
            // the bound columns for SI values immediately follow that of
            // the geometry value column.  This ordering is determined by 
            // SetBindVariables().

            FdoInt32 index = geomBindIndex + 1;
            const wchar_t *wcharValue = geomSiKeys->GetString(0);
			if( mConnection->GetGdbiCommands()->SupportsUnicode() )
			{
				wcsncpy((wchar_t*)bind[index].value.strvalue, wcharValue, bind[index].len);
				((wchar_t*)bind[index].value.strvalue)[bind[index].len-1] = '\0';
			}
			else
			{
				const char* charVal = mConnection->GetUtility()->UnicodeToUtf8( wcharValue );
				strncpy((char*)bind[index].value.strvalue, charVal, bind[index].len);
				((char*)bind[index].value.strvalue)[bind[index].len-1] = '\0';
			}
            mConnection->GetGdbiCommands()->set_nnull( &bind[index].null_ind, 0, 0 );

            if (geomSiKeys->GetCount() > 1)
            {
                index = geomBindIndex + 2;
                wcharValue = geomSiKeys->GetString(1);
			    if( mConnection->GetGdbiCommands()->SupportsUnicode() )
			    {
				    wcsncpy((wchar_t*)bind[index].value.strvalue, wcharValue, bind[index].len);
				    ((wchar_t*)bind[index].value.strvalue)[bind[index].len-1] = '\0';
			    }
			    else
			    {
				    const char* charVal = mConnection->GetUtility()->UnicodeToUtf8( wcharValue );
				    strncpy((char*)bind[index].value.strvalue, charVal, bind[index].len);
				    ((char*)bind[index].value.strvalue)[bind[index].len-1] = '\0';
			    }
                mConnection->GetGdbiCommands()->set_nnull( &bind[index].null_ind, 0, 0 );
            }
        }
    }
}

void FdoRdbmsPvcInsertHandler::SetAditionalBindVariables(const FdoSmLpClassDefinition *currentClass, 
						  const wchar_t *scope, int &bind_no, 
						  FdoPropertyValueCollection  *propValCollection, 
						  FdoRdbmsPvcBindDef *bind, int gid)
{
	// Nothing to add
}

void FdoRdbmsPvcInsertHandler::SetBindVariables(const FdoSmLpClassDefinition *currentClass, 
												const wchar_t *scope, int &bind_no, FdoPropertyValueCollection  *propValCollection, FdoRdbmsPvcBindDef *bind, int gid)
{
    const FdoSmLpPropertyDefinitionCollection *propertyDefinitions = currentClass->RefProperties();
    int i;
    const FdoSmPhDbObject* classTab = currentClass->RefDbObject()->RefDbObject();
	DbiConnection *mConnection = mFdoConnection->GetDbiConnection();
    for (i=0; i<propertyDefinitions->GetCount(); i++)
    {
        const FdoSmLpPropertyDefinition *propertyDefinition = propertyDefinitions->RefItem(i);
        FdoPropertyType  propType = propertyDefinition->GetPropertyType();
		if( ! mBindUnsetValues )
		{
			FdoPtr<FdoPropertyValue>propVal = propValCollection->FindItem( propertyDefinition->GetName() );
			if( propVal == NULL )
				continue;

			FdoPtr<FdoValueExpression>exp = propVal->GetValue();
			if( exp == NULL )
				continue;
		}
        switch ( propType )
        {
            case FdoPropertyType_DataProperty:
            {
                const FdoSmLpDataPropertyDefinition* dataProp =
                    static_cast<const FdoSmLpDataPropertyDefinition*>(propertyDefinition);

                if( dataProp->RefContainingDbObject() != classTab )
                    continue;
                // We update feat id even though it's a system column.
                // We update read-only properties only if they are autogenerated.
                //if ( (dataProp->RefIsSystem() == true ||
               //       (dataProp->RefReadOnly() == true && dataProp->RefIsAutoGenerated() == false) ) &&
                //    dataProp->RefIsFeatId() == false )
                //  continue;


                const FdoSmPhColumn *column = dataProp->RefColumn();
                if (NULL == column)
                {
                    throw FdoRdbmsException::Create(NlsMsgGet1(
                            FDORDBMS_485,
                            "No column for property '%1$ls'.",
                            dataProp->GetName()));
                }
                const wchar_t *colName = column->GetName();

                if ( ! mInsertAutoIncrementProperties && column->GetAutoincrement() )
                    continue;

                FdoDataType dataType =dataProp->GetDataType();
                const FdoSmLpDataPropertyDefinition *prop = FdoSmLpDataPropertyDefinitionCollection::ColName2Property(currentClass->RefProperties(), colName);
                FdoStringP qPropName = prop->GetName();
                if( scope[0] != '\0' )
                    qPropName = FdoStringP(scope) + L"." + prop->GetName();

                // Initialize the bind item
                wcscpy(bind[bind_no].name, colName);
                wcsncpy(bind[bind_no].propertyName, (const wchar_t*)qPropName, GDBI_SCHEMA_ELEMENT_NAME_SIZE );
                bind[bind_no].propertyName[GDBI_SCHEMA_ELEMENT_NAME_SIZE-1] = '\0';
                bind[bind_no].type = dataType;
                bind[bind_no].len = 64;     // Set the length to be 64
                bind[bind_no].reader = NULL;
                bind[bind_no].value.strvalue = NULL;
				bind[bind_no].valueNeedsFree = false;

                char temp[32];
                sprintf(temp, "%d", bind_no+1); // Parm name are one based

                if (dataType == FdoDataType_String)
                {
                    // Increase the length if necessary
                    int size = column->GetLength()+1;
                    if (size > bind[bind_no].len)
                        bind[bind_no].len = size;
                }


                // For BLOBs by-value do binding later in SetBindValues() since the size is not known
                // For BLOBs by-reference (using streams) in SetBindValues() too (needs to check the value)
                if ( dataType != FdoDataType_BLOB )
                {
					int rdbi_type = RDBI_WSTRING;
					if( dataType != FdoDataType_String || ! mConnection->GetGdbiCommands()->SupportsUnicode() )
					{
						bind[bind_no].value.strvalue = new char[bind[bind_no].len];
						bind[bind_no].valueNeedsFree = true;
						rdbi_type = RDBI_STRING;
					}
					else
					{
						bind[bind_no].value.strvalue = new wchar_t[bind[bind_no].len];
						bind[bind_no].valueNeedsFree = true;
					}
                    mConnection->GetGdbiCommands()->bind(gid, temp, rdbi_type, bind[bind_no].len,
                                        (char*)bind[bind_no].value.strvalue, &bind[bind_no].null_ind);
                }
                bind_no++;

                break;
            }

            case FdoPropertyType_GeometricProperty:
            {
                if ( wcscmp(propertyDefinition->GetName(), L"Bounds") == 0 )
                    break;

                const FdoSmLpGeometricPropertyDefinition* geomProp =
                    static_cast<const FdoSmLpGeometricPropertyDefinition*>(propertyDefinition);

                FdoStringP qPropName = geomProp->GetName();
                if( scope[0] != '\0' )
                    qPropName = FdoStringP(scope) + L"." + geomProp->GetName();
                char temp[32];
                const wchar_t *colName = NULL;

                FdoSmOvGeometricColumnType columnType = geomProp->GetGeometricColumnType();

                switch (columnType)
                {
                case FdoSmOvGeometricColumnType_Default:
                case FdoSmOvGeometricColumnType_BuiltIn:
                case FdoSmOvGeometricColumnType_Blob:
                case FdoSmOvGeometricColumnType_Clob:
                case FdoSmOvGeometricColumnType_String:
                    {
                        const FdoSmPhColumn *column = geomProp->RefColumn();
                        colName = column->GetName();
                        wcscpy(bind[bind_no].name, colName);
                        wcsncpy(bind[bind_no].propertyName, (const wchar_t*)qPropName, GDBI_SCHEMA_ELEMENT_NAME_SIZE );
                        bind[bind_no].propertyName[GDBI_SCHEMA_ELEMENT_NAME_SIZE-1] = '\0';
                        bind[bind_no].type = FdoRdbmsDataType_Geometry; // WE DON'T HAVE A FDO TYPE for GEOMETRY
                        bind[bind_no].len = sizeof(FdoIGeometry *);
                        sprintf(temp, "%d", bind_no+1); // Parm name are one based
                        mConnection->GetGdbiCommands()->bind(gid, temp, RDBI_GEOMETRY, bind[bind_no].len,
                                            (char *)&bind[bind_no].value.strvalue, &bind[bind_no].null_ind);
                        bind_no++;
                    }
                    break;
                case FdoSmOvGeometricColumnType_Double:
                    {
                        const FdoSmPhColumn *columnX = geomProp->RefColumnX();
                        const FdoSmPhColumn *columnY = geomProp->RefColumnY();
                        const FdoSmPhColumn *columnZ = geomProp->RefColumnZ();

                        if (NULL != columnX && NULL != columnY)
                        {
                            // Handle X ordinate column.
                            colName = columnX->GetName();
                            wcscpy(bind[bind_no].name, colName);
                            wcsncpy(bind[bind_no].propertyName, (const wchar_t*)qPropName, GDBI_SCHEMA_ELEMENT_NAME_SIZE );
                            bind[bind_no].propertyName[GDBI_SCHEMA_ELEMENT_NAME_SIZE-1] = '\0';
                            bind[bind_no].type = FdoDataType_Double;
                            bind[bind_no].len = 64;     // Set the length to be 64
                            bind[bind_no].reader = NULL;
                            sprintf(temp, "%d", bind_no+1); // Parm name are one based
					        int rdbi_type = RDBI_STRING;
					        bind[bind_no].value.strvalue = new char[bind[bind_no].len];
					        bind[bind_no].valueNeedsFree = true;
                            mConnection->GetGdbiCommands()->bind(gid, temp, rdbi_type, bind[bind_no].len,
                                                (char*)bind[bind_no].value.strvalue, &bind[bind_no].null_ind);
                            bind_no++;

                            // Handle Y ordinate column.
                            colName = columnY->GetName();
                            wcscpy(bind[bind_no].name, colName);
                            wcsncpy(bind[bind_no].propertyName, (const wchar_t*)qPropName, GDBI_SCHEMA_ELEMENT_NAME_SIZE );
                            bind[bind_no].propertyName[GDBI_SCHEMA_ELEMENT_NAME_SIZE-1] = '\0';
                            bind[bind_no].type = FdoDataType_Double;
                            bind[bind_no].len = 64;     // Set the length to be 64
                            bind[bind_no].reader = NULL;
                            sprintf(temp, "%d", bind_no+1); // Parm name are one based
					        bind[bind_no].value.strvalue = new char[bind[bind_no].len];
					        bind[bind_no].valueNeedsFree = true;
                            mConnection->GetGdbiCommands()->bind(gid, temp, rdbi_type, bind[bind_no].len,
                                                (char*)bind[bind_no].value.strvalue, &bind[bind_no].null_ind);
                            bind_no++;

                            // Handle Z ordinate column.
                            if (NULL != columnZ)
                            {
                                colName = columnZ->GetName();
                                wcscpy(bind[bind_no].name, colName);
                                wcsncpy(bind[bind_no].propertyName, (const wchar_t*)qPropName, GDBI_SCHEMA_ELEMENT_NAME_SIZE );
                                bind[bind_no].propertyName[GDBI_SCHEMA_ELEMENT_NAME_SIZE-1] = '\0';
                                bind[bind_no].type = FdoDataType_Double;
                                bind[bind_no].len = 64;     // Set the length to be 64
                                bind[bind_no].reader = NULL;
                                sprintf(temp, "%d", bind_no+1); // Parm name are one based
    					        bind[bind_no].value.strvalue = new char[bind[bind_no].len];
					            bind[bind_no].valueNeedsFree = true;
                                mConnection->GetGdbiCommands()->bind(gid, temp, rdbi_type, bind[bind_no].len,
                                                    (char*)bind[bind_no].value.strvalue, &bind[bind_no].null_ind);
                                bind_no++;
                            }
                        }
                    }
                    break;
                default:
                    // Nothing useful to do here.
                    continue;
                }   // end of switch (columnType)

                // Set up spatial index columns.
                const FdoSmPhColumn *columnSi1 = geomProp->RefColumnSi1();
                const FdoSmPhColumn *columnSi2 = geomProp->RefColumnSi2();
                if (NULL != columnSi1 && NULL != columnSi2)
                {
                    colName = columnSi1->GetName();
                    wcscpy(bind[bind_no].name, colName);
                    wcsncpy(bind[bind_no].propertyName, (const wchar_t*)qPropName, GDBI_SCHEMA_ELEMENT_NAME_SIZE );
                    bind[bind_no].propertyName[GDBI_SCHEMA_ELEMENT_NAME_SIZE-1] = '\0';
                    bind[bind_no].type = FdoDataType_String;
                    bind[bind_no].len = columnSi1->GetLength()+1;
                    sprintf(temp, "%d", bind_no+1); // Parm name are one based
					int rdbi_type = RDBI_WSTRING;
					if( ! mConnection->GetGdbiCommands()->SupportsUnicode() )
					{
						bind[bind_no].value.strvalue = new char[bind[bind_no].len];
						rdbi_type = RDBI_STRING;
					}
					else
					{
						bind[bind_no].value.strvalue = new wchar_t[bind[bind_no].len];
					}
					bind[bind_no].valueNeedsFree = true;
                    mConnection->GetGdbiCommands()->bind(gid, temp, rdbi_type, bind[bind_no].len,
                                        (char*)bind[bind_no].value.strvalue, &bind[bind_no].null_ind);
                    bind_no++;

                    colName = columnSi2->GetName();
                    wcscpy(bind[bind_no].name, colName);
                    wcsncpy(bind[bind_no].propertyName, (const wchar_t*)qPropName, GDBI_SCHEMA_ELEMENT_NAME_SIZE );
                    bind[bind_no].propertyName[GDBI_SCHEMA_ELEMENT_NAME_SIZE-1] = '\0';
                    bind[bind_no].type = FdoDataType_String;
                    bind[bind_no].len = columnSi2->GetLength()+1;
                    sprintf(temp, "%d", bind_no+1); // Parm name are one based
					rdbi_type = RDBI_WSTRING;
					if( ! mConnection->GetGdbiCommands()->SupportsUnicode() )
					{
						bind[bind_no].value.strvalue = new char[bind[bind_no].len];
						rdbi_type = RDBI_STRING;
					}
					else
					{
						bind[bind_no].value.strvalue = new wchar_t[bind[bind_no].len];
					}
					bind[bind_no].valueNeedsFree = true;
                    mConnection->GetGdbiCommands()->bind(gid, temp, rdbi_type, bind[bind_no].len,
                                        (char*)bind[bind_no].value.strvalue, &bind[bind_no].null_ind);
                    bind_no++;
                }
                break;
            }

            case FdoPropertyType_AssociationProperty:
            {
                const FdoSmLpAssociationPropertyDefinition* associationPropertyDefinition = static_cast<const FdoSmLpAssociationPropertyDefinition*>(propertyDefinition);
                if( associationPropertyDefinition->GetReadOnly() )
                    break;
                //
                // We only add the column if the identity properties are not set; translation: we added axtra column
                // to link to the associated class. And if the identity properties are set, it mean we are using existing
                // properties/columns and there is no need to add any column as those column will be added as data properties.
                // For the latest case, we do some sanity check to make sure the duplicate entry(if any) are the same.
                const FdoStringsP   identCollection = associationPropertyDefinition->GetIdentityProperties();
                if( identCollection->GetCount() == 0 )
                {
                    const FdoSmLpDataPropertyDefinitionCollection *identPropCol =  associationPropertyDefinition->RefAssociatedClass()->RefIdentityProperties();
                    const FdoSmPhColumnListP identCols  = associationPropertyDefinition->GetReverseIdentityColumns();
                    if( identCols->GetCount() != identPropCol->GetCount() )
                        throw FdoCommandException::Create(NlsMsgGet(FDORDBMS_292, "Association identity properties and identity columns mismatch"));

                    for(int i=0; i<identCols->GetCount(); i++ )
                    {
                        const FdoSmLpDataPropertyDefinition *prop = identPropCol->RefItem( i );
                        FdoStringP assoPropName = FdoStringP::Format(L"%ls.%ls",propertyDefinition->GetName(), prop->GetName());
                        wcsncpy(bind[bind_no].propertyName, (const wchar_t *)assoPropName, GDBI_SCHEMA_ELEMENT_NAME_SIZE );
                        bind[bind_no].propertyName[GDBI_SCHEMA_ELEMENT_NAME_SIZE-1] = '\0';
                        bind[bind_no].type = prop->GetDataType();

                        char temp[32];
                        sprintf(temp, "%d", bind_no+1); // Parm name are one based
                        // Set the length to be 64
                        bind[bind_no].len = 64;
                        if (bind[bind_no].type == FdoDataType_String)
                        {
                            const FdoSmPhColumn *column = prop->RefColumn();
                            // Increase the length if necessary
                            int size = column->GetLength()+1;
                            if (size > bind[bind_no].len)
                                bind[bind_no].len = size;
                        }
                        bind[bind_no].value.strvalue = new char[bind[bind_no].len];
                        mConnection->GetGdbiCommands()->bind(gid, temp, RDBI_STRING, bind[bind_no].len,
                                          (char*)bind[bind_no].value.strvalue, &bind[bind_no].null_ind);

                        bind_no++;
                    }
                }
            }
               break;

            case FdoPropertyType_ObjectProperty:
            {
                const FdoSmLpObjectPropertyDefinition* objProp = static_cast<const FdoSmLpObjectPropertyDefinition*>(propertyDefinition);
                const FdoSmLpPropertyMappingDefinition* mappping = objProp->RefMappingDefinition();
                if ( mappping->GetType() != FdoSmLpPropertyMappingType_Single )
                    break; // We only handle the single mapping

                const FdoSmLpPropertyMappingSingle * singleMapping = static_cast<const FdoSmLpPropertyMappingSingle*>( mappping );
                FdoStringP newScope = propertyDefinition->GetName();
                if( scope[0] != '\0' )
                    newScope = FdoStringP(scope) + L"." + propertyDefinition->GetName();
                SetBindVariables(objProp->RefTargetClass(),(const wchar_t*)newScope, bind_no, propValCollection, bind, gid);
            }
                break;
            default:
                break;
        }
    }
}

InsertQueryDef *FdoRdbmsPvcInsertHandler::GetInsertQuery( const wchar_t *tableName, bool alloc_new )
{
    int         i;

	DbiConnection *mConnection = mFdoConnection->GetDbiConnection();

	if( ! alloc_new )
	{
		if( wcscmp( mLastTableName, tableName ) == 0 )
			return mLastInsertQuery;
		else
			wcscpy( mLastTableName, tableName );

		for( i=0; i<QUERY_CACHE_SIZE; i++ )
		{
			if( wcscmp( tableName, mInsertQueryCache[i].tableName ) == 0 )
			{
				mLastInsertQuery = &mInsertQueryCache[i];
				return &mInsertQueryCache[i];
			}
		}
	}
    // Find a free slot
    for( i=0; i<QUERY_CACHE_SIZE; i++ )
    {
        if( mInsertQueryCache[i].qid == -1 )
        {
            wcsncpy( mInsertQueryCache[i].tableName, tableName, GDBI_SCHEMA_ELEMENT_NAME_SIZE );
            mInsertQueryCache[i].tableName[GDBI_SCHEMA_ELEMENT_NAME_SIZE - 1] = '\0';
            mLastInsertQuery = &mInsertQueryCache[i];
            return &mInsertQueryCache[i];
        }
    }

    // We didn't find one free: Let's reuse an existing one.
    int    nextIdx = mNextQidToFree%QUERY_CACHE_SIZE;
    mNextQidToFree ++;

    // Free the resources allocated by the previous query
    if( mInsertQueryCache[nextIdx].qid != -1 )
        mConnection->GetGdbiCommands()->free_cursor(mInsertQueryCache[nextIdx].qid);
    if( mInsertQueryCache[nextIdx].bind != NULL )
    {
        for (int i=0; i<mInsertQueryCache[nextIdx].count; i++)
		{
			if( mInsertQueryCache[nextIdx].bind[i].value.strvalue == NULL )
				continue;
			if (mInsertQueryCache[nextIdx].bind[i].type == FdoRdbmsDataType_Geometry)
			{
                    ((FdoIGeometry*)mInsertQueryCache[nextIdx].bind[i].value.strvalue)->Release ();
					mInsertQueryCache[nextIdx].bind[i].value.strvalue = NULL;
			}
            else if( mInsertQueryCache[nextIdx].bind[i].valueNeedsFree )
		    {
				delete [] (char*)mInsertQueryCache[nextIdx].bind[i].value.strvalue;
				mInsertQueryCache[nextIdx].bind[i].value.strvalue = NULL;
				mInsertQueryCache[nextIdx].bind[i].valueNeedsFree = false;
			}
		}
        delete [] mInsertQueryCache[nextIdx].bind;
    }
    mInsertQueryCache[nextIdx].qid = -1;

    // Mark it for the new table
    wcsncpy( mInsertQueryCache[nextIdx].tableName, tableName, GDBI_SCHEMA_ELEMENT_NAME_SIZE );
    mInsertQueryCache[nextIdx].tableName[GDBI_SCHEMA_ELEMENT_NAME_SIZE - 1] = '\0';
    mLastInsertQuery = &mInsertQueryCache[nextIdx];
    return &mInsertQueryCache[nextIdx];
}

void FdoRdbmsPvcInsertHandler::AssociationConstrainCheck( const FdoSmLpAssociationPropertyDefinition* propertyDefinition,
                                    FdoPropertyValueCollection  *propValCollection )
{
    const wchar_t* multiplicity = propertyDefinition->GetMultiplicity();
    const wchar_t* revMultiplicity = propertyDefinition->GetReverseMultiplicity();

    // The association property should be initialized if the multiplicity is "1"; We need to insert the asociation with the object.
    if( FdoRdbmsUtil::StrCmp( revMultiplicity, L"1") == 0 )
    {
        FdoPtr<FdoValueExpression> identVal;
        const FdoStringsP   identCollection = propertyDefinition->GetIdentityProperties();
        if( identCollection->GetCount() == 0 )
        {
            const FdoSmLpDataPropertyDefinitionCollection *identPropCol =  propertyDefinition->RefAssociatedClass()->RefIdentityProperties();
            for(int i=0; i<identPropCol->GetCount(); i++ )
            {
                const FdoSmLpDataPropertyDefinition *prop = identPropCol->RefItem( i );
                FdoStringP idenName = FdoStringP::Format(L"%ls.%ls",propertyDefinition->GetName(), prop->GetName());
                try
                {
                    FdoPtr<FdoPropertyValue> identPropertyValue = propValCollection->GetItem( (const wchar_t*)(idenName) );
                    identVal = identPropertyValue->GetValue();
                }
                catch(FdoException *exp )
                {
                    exp->Release();
                    identVal = NULL;
                    break;
                }
            }
        }
        else
        {
            const FdoStringsP   revIdentCollection = propertyDefinition->GetReverseIdentityProperties();
            for( int i=0; i<revIdentCollection->GetCount(); i++ )
            {
                try
                {
                    FdoPtr<FdoPropertyValue>identPropertyValue = propValCollection->GetItem( (const wchar_t*)(revIdentCollection->GetString(i)) );
                    identVal = identPropertyValue->GetValue();
                }
                catch(FdoException *exp )
                {
                    exp->Release();
                    identVal = NULL;
                    break;
                }
            }
        }
        if( identVal == NULL )
        {
            throw FdoCommandException::Create(NlsMsgGet(FDORDBMS_289, "Association property is required" ) );
        }
    }

    // Only one-to-one association exists; make sure we don't already have an association to the same instance.
    if( FdoRdbmsUtil::StrCmp( multiplicity, L"1") == 0 )
    {
        // We need to make a query to see if an association between the associated instance and an instance of this
        // class exists already.
        // This is potentially a performance killer as a select would trigger the flush of the cach.
        // Also, this is an issue if subclassing is involved as any number of subclasses can be
        // Associsted to this instance. That means we need to search every subclass instances for refrence
        // to the associated instance.
    }

    //TODO We need to make sure that the associated instance exists. This is a performace issue as we are forcing a cach flush.
    // May be we should ignore the existance of the associated instance is the multiplicity is set to "m".

}

