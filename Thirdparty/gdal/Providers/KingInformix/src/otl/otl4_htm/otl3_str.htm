<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
   <TITLE>OTL 4.0, OTL stream class</TITLE>
   <META NAME="Author" CONTENT="Sergei Kuchin">
   <META NAME="GENERATOR" CONTENT="Mozilla/3.03Gold (Win95; I) [Netscape]">
   <META NAME="KeyWords" CONTENT="OTL, Oracle, ODBC, DB2, CLI, database API, C++, Template Library">
</HEAD>
<BODY>

<H1 ALIGN=CENTER>OTL 4.0, OTL stream concept</H1>

<H1><A NAME="otl_stream"></A>OTL stream concept</H1>

<P>Any SQL statement, PL/SQL block or a stored procedure call is characterized
by its input / output [variables]. </P>

<P><B>Example 1.</B> A SELECT statement has scalar input variables that
are used in the WHERE clause of the statement. The SELECT statement also
defines output columns. Potentially, the output columns are vector parameters
since the SELECT statement may return multiple rows. </P>

<P><B>Example 2. </B>An INSERT statement writes data into a table, i.e.
it has input parameters. Same is true for UPDATE statemements. </P>

<P><B>Example 3.</B> A DELETE statement deletes rows from a table. Deletion
criteria needs to be entered, thus the DELETE statement has input.</P>

<P><B>Example 4. </B>A stored procedure may have input and/or output parameters.
Usually, stored procedure parameters are scalars. There is a special case,
though: stored procedure returning a referenced cursor (Oracle) or a result
set (MS SQL Server or Sybase).</P>

<P><B>Example 5. </B>An arbitrary PL/SQL block may have input or/and output
parameters that may be either scalars or vectors.</P>

<P><A NAME="bulk"></A>Industrial strength database servers have bulk (or
array) operations:</P>

<UL>
<LI>bulk INSERT</LI>

<LI>bulk UPDATE</LI>

<LI>bulk DELETE</LI>

<LI>bulk SELECT</LI>
</UL>

<P>Therefore, parameters in INSERT/UPDATE/DELETE statement may be vectors
if the statement is performed in bulk.</P>

<P>The picture is clear: any interaction with SQL or its procedural extension
can be treated as a black box with input and/or output. It does not matter
what the black box does inside (according to the definition of a black
box). What matters is the <I><TT>input wires</TT> </I>that send signals
<I>into</I> the box and the <I>output wires</I> that receive signals <I>from
</I>the box:</P>

<CENTER><P><IMG SRC="otlodbc.gif" HEIGHT=420 WIDTH=420></P></CENTER>

<P>Some of the wires may be both <I>input </I>and <I>output</I>. </P>

<P>Why not combine the concept of data streams and SQL? Instead of multiplying
constructs and making database API's too convoluted, why not unify and
simplify them? The OTL gives an answer to those questions and the answer
is the <A HREF="otl3_stream_class.htm">otl_stream class</A>.</P>

<P>Since a SQL statement may be done in bulk, the otl_stream is a buffered
stream. Conceptually, the otl_stream has two separate buffers: input and
output. The input buffer is comprised of all input variables put together.
Respectively, the output buffer is comprised of all output variables put
together. </P>

<P>C++ streams are usually manipulated via operator &gt;&gt; and operator
&lt;&lt;. The stream reference is on the left of the operator symbol: </P>

<PRE>   s&gt;&gt;variable;
   s&lt;&lt;variable;</PRE>

<P>The double arrow shows the direction in which data goes: </P>

<UL>
<LI>&gt;&gt; -- from the stream into the data container (variable)</LI>

<LI>&lt;&lt; -- from the data container (variable) into the stream</LI>
</UL>

<P>OTL streams are similar to buffered C++ streams . A SQL statement or
stored procedure call is opened as an ordinary buffered stream. The logic
of the OTL stream operations remains the same as the C++ stream operations
with the only exception -- the OTL stream has separate input and output
buffers which may overlap. </P>

<P>The OTL stream has a flush function for flushing its input buffer when
the buffer gets full and a collection of &gt;&gt; and &lt;&lt; operators
for reading and writing objects of different data types. The most important
advantage of the OTL streams is their unified interface to SQL statements
and stored procedure call of any kind. This means that the application
developer needs to remember just a few syntactical constructs and function
names which he already got familiar with when he started working with C++
streams. </P>

<P>Inside the OTL stream there is a small parser for parsing <A HREF="otl3_bind_variables.htm">declarations
of bind variables and their data types</A>. There is no need to declare
C/C++ host variables and bind them with placeholders by special bind function
calls. All necessary buffers are created dynamically inside the stream.
The stream just needs to be opened for reading and writing values.</P>

<P>The OTL stream interface requires use of the OTL exceptions. This means
that potentially any OTL stream operation can throw an exception of the
<A HREF="otl3_exception_class.htm">otl_exception</A> type. In order to
intercept the exception and prevent the program from aborting, wrap up
the OTL stream code with the corresponding try &amp; catch block.</P>

<P>The functioning of the otl_stream is pretty much automatic: when all
of the input variables of the stream are defined (in other words, the input
buffer is filled out), it triggers the block box inside the stream to execute.
The output buffer gets filled out in the process of the execution of the
black box. After the execution is finished, the output values can be read
from the stream. If it is a SELECT statement and it returns more rows than
the output buffer can hold, after the whole output buffer is read, then
the stream automatically fetches the next bacth of rows into the output
buffer.</P>

<P>
<HR WIDTH="100%"></P>

<CENTER><P><A HREF="otl3_intro.htm">Prev</A> <A HREF="otl3_class.htm">Next</A>
<A HREF="otl3.htm">Contents</A> <A HREF="home.htm">Go Home</A> </P></CENTER>

<P>Copyright &copy; 1996, 2007, Sergei Kuchin, email: <A HREF="mailto:skuchin@ispwest.com">skuchin@ispwest.com</A>,
<A HREF="mailto:skuchin@gmail.com">skuchin@yahogmail</A>
<SCRIPT Language="JavaScript">
<!-- hide from old browsers
 var modDate = new Date(document.lastModified)
 document.write("<i> Last Updated:</i> " + (modDate.getMonth()+1) + "/" + 
                modDate.getDate() + "/" + "0"+(modDate.getYear())%100+".");
 //-->
 </SCRIPT>
.</P>

<P><I>Permission to use, copy, modify and redistribute this document for
any purpose is hereby granted without fee, provided that the above copyright
notice appear in all copies. </I></P>

</BODY>
</HTML>
