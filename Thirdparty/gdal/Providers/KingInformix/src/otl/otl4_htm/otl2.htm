<html>
<head>
<title>One-Page Oracle API, Oracle Call Interface Template Library
(OTL), Version 2.0.0</title>
</head>
<body>
<h1>One-Page Oracle API, Oracle Call Interface Template Library (OTL),
Version 2.0.0</h1>
<p><i>Sergei Kuchin, email:
<a href="mailto:skuchin@ispwest.com">skuchin@ispwest.com</a>,
<a href="mailto:skuchin@gmail.com">skuchin@gmail.comgmail</i>
<xmp>
Copyright (C) Sergei Kuchin, 1996, 1997, 1998
Permission to use, copy, modify and redistribute this
document for any purpose is hereby granted without fee,
provided that the above copyright notice appear in all
copies.
</xmp>
<h1>Table of Contents</h1>
<ul>
<li><a href="#sec1">1. Introduction</a>
<li><a href="#sec11">1.1. SQL streams</a>
<li><a href="#sec2">2. <i>One-page</i> Oracle API</a>
<ul>
<li><a href="#sec21">2.1. Connect object</a>
<li><a href="#sec22">2.2. otl_stream class</a>
<ul>
<li><a href="#sec221">2.2.1. Stream bind variables declaration</a>
</ul>
<li><a href="#sec23">2.3. Exception handling</a>
<li><a href="#sec24">2.4. Constant SQL statement or PL/SQL block</a>
<li><a href="#sec25">2.5. Examples</a>
</ul>
<li><a href="#sec3">3. STL-compliant iterators for otl_stream</a>
<ul>
<li><a href="#sec31">3.1. Example</a>
</ul>
<li><a href="#app_a">Appendix A. How to download the source code</a>
<li><a href="#app_b">Appendix B. OTL exception list</a>
</ul>
<h1><a name="sec1"> 1. Introduction</h1>
<p>
This document describes the Oracle Call Interface Template Library,
Version 2.0.0 (OTL). The library introduces a <i>one-page</i> Oracle
API in the form of  <a href="#sec11">SQL streams</a>.
</p>
<p>
OTL is a new kind of C++ libraries, similar to the <a
href="http://www.sgi.com/Technology/STL/">Standard Template
Library</a>. This kind of libraries is easy to use, since the user
needs only to include C++ header files which contain template classes
and inlinr functions. There is no need to link additional object
modules into C++ applications. The code instantiated from template
classes and inline functions is efficient and reliable in terms of
runtime performance and C++ strict type checking.
</p>
<p>
OTL automatically uses Oracle Array Interface (<a href="#sec11">SQL
streams</a> are buffered by definition) and has a higher runtime
performance than Pro*C because there is no overhead on caching cursors
and filling out the SQLCA global structure before every single SQL
statement embedded into the program. Runtime performance can be
improved even further by increasing the stream buffer size.
</p>
<p>
OTL provides an exception handling mechanism in the format of the <a
href="#sec23">otl_exception</a> class. This mechanism takes advantage
of C++ exception handling compared to coding database applications in
plain C. The user does not need to check out return codes after each
function call. The code, instantiated from the OTL templates and
inline functions is much nicer and cleaner in comparison with the code
generated by the Pro*C precompiler.
</p>
<p>
Also, OTL integrates with the <a
href="http://www.sgi.com/Technology/STL/">Standard Template
Library</a> by means of <a href="#sec3">STL-compliant iterator
classes</a>. This feature is very powerful because it allows to
combine the power of <a
href="http://www.metabyte.com/~fbp/stl/readings.html">generic
programming</a> and Oracle database backend into compact, reliable,
top performance and easy-to-maintain C++ database applications.
</p>
<p>
This version of OTL is available for both Oracle 7.x and Oracle
8.x. Both implemetations use native OCIs:
</p>
<ul>
<li>OTL for Oracle 7 uses native OCI7
</li>
<li>OTL for Oracle 8 uses native OCI8
</li>
</ul>
<p>
It provides smooth transition from Oracle 7 to Oracle 8 with no
changes to the custom source code. Besides, OTL compiles by many C++
compilers on major brands of Unix as well as Windows NT and Windows
95/98.
</p>
<p>
The fact that OTL is available in source code adds more value to this
material -- folks new to OCI can use the OTL source code to learn both
OCI7 and OCI8 . Moreover, OTL can be used a guidance for migrating
programs from native OCI7 to native OCI8.
</p>

<h2><a name="sec11">1.1. SQL stream classes</h2>
<p>
OTL introduces the concept of SQL streams. The idea here is to
combine streams and SQL. Any SQL statement or PL/SQL block can be
treated as a functional element with input/output parameters.  There
are functions to put objects into a stream, that is, to assign values
to input variables of the SQL statement. Also, there are functions to
get objects from the stream, that is, to get values from output
variables of the SQL statement.
</p>
<center>
<img src="otl.gif">
</center>
<p>
When values of all input variables of the functional element
are filled out then the element is executed. Resulting
values are assigned to the output variables right after the
execution. Sets of input and output variables are allowed to
overlap.
</p>
<p>
Logically, a SQL stream is a structured stream with input
and output rows. The format of the input row is defined by a
set of output variables of the stream. Similarly, the output
row is defined by input variables of the stream. When
objects are written into the stream, values are actually
assigned to the input variables. Likewise, when objects are
read from the stream, values are read from the output
variables of the stream.
</p>
<p>
SQL streams are similar to buffered files. A SQL statement
or PL/SQL block is opened as an ordinary buffered file. The
logic of the SQL stream operations remains the same as the
file operations with the only exception -- the SQL stream
has separate input and output buffers which may overlap.
</p>
<p>
The SQL stream has a flush function for flushing its input buffer when
the buffer gets full and a collection of >> and << operators for
reading and writing object of different data types. The most important
advantage of the SQL streams is their unified interface to SQL
statements and PL/ SQL blocks of any kind. This means that the
application developer needs to remember just a few syntactical
constructs and function names which he already got familiar with when
he started working with C++ streams.
</p>
<p>
Inside the SQL stream there is a small parser for parsing <a
href="#sec221">declarations of bind variables</a> and their data
types. There is no need to declare C/C++ host variables and bind them
with placeholders by special bind function calls. All necessary
buffers are created dynamically inside the stream. The stream just
needs to be opened for reading input values and writing output values.
</p>
<p>
The OTL stream interface requires use of the OTL exceptions. This
means that potentially any OTL stream operation can throw an exception
of the <a href="#sec23">otl_exception</a> type. In order to intercept
the exception and prevent the program from aborting, wrap up the OTL
stream code with the corresponding try & catch block.
</p>

<h1><a name="sec2">2. <i>One-page</i> Oracle API</h1>

<h2><a name="sec21">2.1. Connect object</h2>

<p>
This class encapsulates the Oracle Call Interface <i>connect</i>
functions: connect, commit, roll back, etc.  In other words,
otl_connect is the class for creating "connect" objects.
</p>
<a name="ref002"></a><xmp>

class otl_connect{
public:

</xmp>
<ul>
<li> Constants to initialize OCI. oci_threaded is needed in case of
multithreaded program. oci_default is the default mode.
<xmp>
 enum {oci_default,oci_threaded};
</xmp>
<li><a name="ref006"></a>Initialize OCI program. This function needs to be called only once
before connecting to the database for the first time. The function is
static in class.
<xmp>
static void otl_initialize(const int mode=oci_default);
</xmp>
<li>Create "connect" object.
<xmp>
otl_connect();
</xmp>
<li>Create "connect" object and connect to Oracle using the
"connect_str" connect string.
<xmp>
 otl_connect(const char* connect_str);
</xmp>
<li>Destructor
<xmp>
~otl_connect();
</xmp>
<li><a name="ref007"></a>Concurrent logon; OCI application is allowed to have more than one
concurrent logon. Returns 1 on success, 0 on failure.
<xmp>
int rlogon(const char* connect_str);
</xmp>
<li><a name="ref009"></a>Disconnect from / log off Oracle. Returns 1 on success, 0 on
failure.
<xmp>
int logoff(void);
</xmp>
<li>Commit current transaction. Returns 1 on success, 0 on failure.
<xmp>
int commit(void);
</xmp>
<li>Roll back current transaction. Returns 1 on success, 0 on failure.
<xmp>
int rollback(void);
</xmp>
</ul>
<xmp>

};

</xmp>

<h2><a name="sec22">2.2. otl_stream class</h2>

<p>
OTL introduces the otl_stream class which is the actual implementation of
the <a href="#sec11">SQL Stream</a> concept. It is unified for any SQL
statement or PL/SQL block which potentially may have input/output bind
variables (placeholders). otl_stream provides the same interface for
both straight SELECT statements and SELECT statements to be returned
via a referenced cursor. Though, implementations are quite different.
</p>
<p>
An OTL stream needs to have at least one <a href="#sec221">bind
variable</a>.  See <a href="#sec24">2.4.</a> for more information on
how to execute a constant SQL statement or PL/SQL block.
</p>

<xmp>
class otl_stream{
public:
</xmp>
<ul>
<li><a name="ref001"></a>General conctructor. SQL statement is parsed, all host input and
output host variables are automatically allocated and bound. This
constructor allows the user to use <a href="#sec221">extended
placeholder declarations</a>.
<xmp>
otl_stream(
	   short arr_size, // host array size
	   const char* sqlstm, // SQL statement 
	   otl_connect& db, // connect object
           const char* ref_cur_placeholder=0
		   // reference cursor placeholder, e.g. ":cur"
	  );
</xmp>
<li>Default constructor
<xmp>
otl_stream();
</xmp>
<li>Destructor
<xmp>
~otl_stream();
</xmp>
<li><a name="ref005"></a>Test if all data has been already read from the stream
<xmp>
int eof(void);
</xmp>
<li><a name="ref010"></a>Flush stream's output buffer. It actually means to execute the SQL
statement as many times as rows entered to the output buffer. The
stream is automatically flushed when the buffer gets full.
<xmp>
void flush(void); 
</xmp>
<li>Clean up buffer without flushing it.
<xmp>
void clean(void);
</xmp>
<li>Rewind stream
<xmp>
void rewind(void);
</xmp>
<li>Test if NULL was fetched from the stream
<xmp>
int is_null(void);
</xmp>
<li>Set "auto-commit" flag. When the buffer is flushed, current
transaction is automatically commited, if the flag is set. By default,
the flag is set. In order to prevent current transaction from
"auto-committing", unset the flag using this function.<br>
This auto-commit flag has nothing to do with the Oracle auto-commit
mode. This auto-commit is otl_stream specific. If it is more
convenient to have "auto-commit off" by default then it makes sense to
derive another stream class from otl_stream and unset the flag in
constructors of the derived class.
<xmp>
void set_commit(int auto_commit=0);

</xmp>
<li>Open stream
<xmp>
void open(
	  short arr_size, // host array size
	  const char* sqlstm, // SQL statement 
	  otl_connect& db, // connect object
          const char* ref_cur_placeholder=0
	     // reference cursor placeholder, e.g. ":cur"
	 );
</xmp>
<li>Close stream
<xmp>
void close(void);
</xmp>
<li>Test if the stream was opened okay
<xmp>
int good(void);
</xmp>
<li><a name="ref004"></a>Read objects from stream
<xmp>
otl_stream& operator>>(char& c);
otl_stream& operator>>(unsigned char& c);
otl_stream& operator>>(char* s);
otl_stream& operator>>(unsigned char* s);
otl_stream& operator>>(int& n);
otl_stream& operator>>(unsigned& u);
otl_stream& operator>>(short& sh);
otl_stream& operator>>(long int& l);
otl_stream& operator>>(float& f);
otl_stream& operator>>(double& d);
</xmp>
<li><a name="ref003"></a>Write objects into stream
<xmp>
otl_stream& operator<<(const char c);
otl_stream& operator<<(const unsigned char c);
otl_stream& operator<<(const char* s);
otl_stream& operator<<(const unsigned char* s);
otl_stream& operator<<(const int n);
otl_stream& operator<<(const unsigned u);
otl_stream& operator<<(const short sh);
otl_stream& operator<<(const long int l);
otl_stream& operator<<(const float f);
otl_stream& operator<<(const double d);
otl_stream& operator<<(const otl_null n); 
  // write Oracle NULL into stream. otl_null is a dummy class
  // which has only a empty default constructor. The only purpose
  // of creating this class was providing a function to write
  // NULL into the database
</xmp>
<li><a name="ref011"></a>C-style printf/scanf functions
<xmp>
void printf(const char* fmt,...);
void scanf(const char* fmt,...);
</xmp>
<p>
The following format specifiers are supported:
</p>
<ul>
<li><b>%d</b>  -- int
<li><b>%u</b>  -- unsigned 
<li><b>%ld</b> -- long int
<li><b>%f</b>  -- float
<li><b>%lf</b> -- double
<li><b>%c</b>  -- char
<li><b>%s</b>  -- string
<li><b>%N</b>  -- specifier for writing NULL into streams
</ul>
</ul>
<xmp>
};
</xmp>

<h2><a name="sec221">2.2.1. Stream bind variables declaration</h2>

<p>
This section explains in detail how to declare bind variables (or
extended placeholders) in the SQL streams.
</p>
<p>
A SQL statement or PL/SQL block may have placeholders which are
usually connected with the corresponding bind variables in the
program. In Pro*C, the user needs to declare such variables directly in
the program. OTL provides the same functionality in another way. There
is a small parser which parses a SQL statament or PL/SQL block
declaration and allocates corresponding bind variables dynamically
inside the stream.
</p>
<p>
The following data types for extneded placeholder declarations are
available:
</p>
<ul>
<li>int
<li>unsigned
<li>short
<li>long -- (long integer)
<li>float
<li>double
<li>char[length] (length >= 3 & length <= 32545)
</ul>

<p>
For PL/SQL blocks, special qualifiers are introduced to distinguish
between input and output variables:
</p>
<li>in    -- input variable
<li>out   -- output variable
<li>inout -- input/output variable
</ul>

<h4>Examples</h4>
<p>
Here is some examples:
</p>
<pre>

 begin
   :rc&lt;int,out&gt; := my_func(:salary&lt;float,in&gt;,  
                           :ID&lt;int,inout&gt;, 
                           :name&lt;char[32],out&gt;
                          );
 end;
</pre>
<p>
Invoke the my_func function; return the function result into
the :rc variable; the function has three parameters: salary
(input), ID (iput/output), name (output)
</p>
<pre>

   select * from tab1 where f1 &gt; :f1&lt;double&gt;

</pre>
<p>
Select all columns from the tab1 table where f1 is greater
than :f1
</p>
<pre>

   insert into tab1 values( :f1&lt;double&gt;, :f2;&lt;char[32]&gt;, :f3&lt;int&gt; )

</pre>
<p>
Insert row { :f1(double), :f2(string), :f3(integer) } into the tab1
table.
</p>
<p>
In the extended placeholder declaration, spaces in the data type
section and in the access qualifier section ARE NOT allowed. The
following code is invalid:
</p>
<xmp>
  insert into tab1 values(:f1< double >, :f2< char [ 32 ] > , :f3< int>);
  :rc< int, out > := ...;
</xmp>

<h2><a name="sec23">2.3. Exception handling</h2>

<p>
In case of Oracle failure or inconsistent use of SQL streams,
exceptions of the otl_exception type are raised by the library
functions. The main advantage of using this exception handling
mechanism is that exceptions can be processed in one catch block,
instead of checking return codes from every library function call.
</p>
<xmp>
class otl_exception{
public:
</xmp>
<ul>
<li><a name="ref008"></a>This <i>enum</i> defines two constants which may be used in the
<a href="#sec24">direct_exec</a> function
<pre>
enum{ disabled, enabled };
</pre>
<li>Create exception out of Logon Descriptor Area (Oracle 7)
or out of OCI error handle (Oracle 8)
<xmp>
otl_exception(Lda_Def& lda,const char* sqlstm=0);
  
                     or 

otl_exception(OCIError* errhp,const char* sqlstm=0)
</xmp>
<li>Create exception from amsg, acode and sqlstm
<xmp>
otl_exception(const char* amsg,const int acode,const char* sqlstm=0);
</xmp>
<li>Copy constructor
<xmp>
otl_exception(const otl_exception& p);
</xmp>
<li>Default constructor
<xmp>
 otl_exception();
</xmp>
<br>
<hr size=3>
<br>
<li>error message buffer
<xmp>
unsigned char msg[1000]; 
</xmp>
<li>error code
<xmp>
int code;
</xmp>
<li>SQL statement or PLSQL block that caused the error
<xmp>
 unsigned char* stm_text;
</xmp>
</ul>


<xmp>
};

</xmp>

<h3>Example</h3>

<xmp>
 try{

  otl_stream s(50, // fetch 50 rows per one fetch operation
	      "select state_name, state_code "
              "from state "
               "where state_name like :v1<char[33]>",
               db // connect object
             );
  char name[33];
  int  code;

  s<<"M%";
  while(!s.eof)){
   s>>name>>code;
   cout<<"State="<<name<<", Code="<<code<<endl;
  }

 }catch(otl_exception& p){ // intercept exception

  cerr<<p.code<<endl; // print out error code
  cerr<<p.msg<<endl; // print out error message
  cerr<<p.stm_text<<endl; // print out SQL that caused the error

 }
</xmp>


<h2><a name="sec24">2.4. Constant SQL statement or PL/SQL block</h2>
<p>
SQL statement or PL/SQL block is considered to be constant if it does
not have any bind variables. OTL has a static (in class) function to
execute constant statements or blocks, e.g.
</p>
<xmp>
  otl_cursor::direct_exec
   (db, // connect object
    "create table test_tab(f1 number, f2 varchar2(30))"
    );  // create table
</xmp>
<p>
otl_cursor is one of OTL internal classes. There is another format of
the direct_exec function call:
</p>
<xmp>
  otl_cursor::direct_exec
   (db, // connect object
    "drop table test_tab", // SQL statement or PL/SQL block
    otl_exception::disabled // disable OTL exceptions,
                            // in other words, ignore any
                            // Oracle error
   ); // drop table

</xmp>

<h2><a name="sec25">2.5. Examples</h2>

<h3>Example 1 (with otl_stream class)</h3>
<h4>Source code</h4>
<pre>

<font color="#FF0000">#include &lt;iostream.h&gt;</font>
<font color="#FF0000">#include &lt;stdio.h&gt;</font>
<font color="#FF0000">#include &lt;otl.h&gt;</font>

<a href="#ref002">otl_connect</a> db; <i><font color="#804000">// connect object</font></i>

<a name="ref101"></a><h4><font color="#0000A0">void</font> insert()</h4>
<i><font color="#804000">// insert rows into table</font></i>
{ 
 <a href="#ref001">otl_stream</a> o(50, <i><font color="#804000">// buffer size</font></i>
	      <font color="#008080">"insert into test_tab values(:f1&lt;float&gt;,:f2&lt;char[31]&gt;)"</font>, 
	         <i><font color="#804000">// SQL statement</font></i>
	      db <i><font color="#804000">// connect object</font></i>
	     );
 <font color="#0000A0">char</font> tmp[32];

 <font color="#0000A0">for</font>(<font color="#0000A0">int</font> i=1;i&lt;=100;++i){
  sprintf(tmp,<font color="#008080">"Name%d"</font>,i);
  o<a href="#ref003">&lt;&lt;</a>(<font color="#0000A0">float</font>)i<a href="#ref003">&lt;&lt;</a>tmp;
 }
}

<a name="ref102"></a><h4><font color="#0000A0">void</font> select()</h4>
{ 
 <a href="#ref001">otl_stream</a> i(50, <i><font color="#804000">// buffer size</font></i>
	      <font color="#008080">"select * from test_tab where f1&gt;=:f&lt;int&gt; and f1&lt;=:f*2"</font>,
	         <i><font color="#804000">// SELECT statement</font></i>
	      db <i><font color="#804000">// connect object</font></i>
	     ); 
   <i><font color="#804000">// create select stream</font></i>
 
 <font color="#0000A0">int</font> f1;
 <font color="#0000A0">char</font> f2[31];

 i<a href="#ref003">&lt;&lt;</a>8; <i><font color="#804000">// assigning :f = 8</font></i>
   <i><font color="#804000">// SELECT automatically executes when all input variables are</font></i>
   <i><font color="#804000">// assigned. First portion of out rows is fetched to the buffer</font></i>

 <font color="#0000A0">while</font>(!i.<a href="#ref005">eof()</a>){ <i><font color="#804000">// while not end-of-data</font></i>
  i<a href="#ref004">&gt;&gt;</a>f1<a href="#ref004">&gt;&gt;</a>f2;
  cout&lt;&lt;<font color="#008080">"f1="</font>&lt;&lt;f1&lt;&lt;<font color="#008080">", f2="</font>&lt;&lt;f2&lt;&lt;endl;
 }
 
 i<a href="#ref003">&lt;&lt;</a>4; <i><font color="#804000">// assigning :f = 4</font></i>
   <i><font color="#804000">// SELECT automatically re-executes when all input variables are</font></i>
   <i><font color="#804000">// assigned. First portion of out rows is fetched to the buffer</font></i>

 <font color="#0000A0">while</font>(!i.<a href="#ref005">eof()</a>){ <i><font color="#804000">// while not end-of-data</font></i>
  i<a href="#ref004">&gt;&gt;</a>f1<a href="#ref004">&gt;&gt;</a>f2;
  cout&lt;&lt;<font color="#008080">"f1="</font>&lt;&lt;f1&lt;&lt;<font color="#008080">", f2="</font>&lt;&lt;f2&lt;&lt;endl;
 }

}

<h4><font color="#0000A0">int</font> main()</h4>
{
 <a href="#ref006">otl_connect::otl_initialize()</a>; <i><font color="#804000">// initialize OCI environment</font></i>
 <font color="#0000A0">try</font>{

  db.<a href="#ref007">rlogon</a>(<font color="#008080">"scott/tiger"</font>); <i><font color="#804000">// connect to Oracle</font></i>

  <a href="#sec24">otl_cursor::direct_exec</a>
   (
    db,
    <font color="#008080">"drop table test_tab"</font>,
    <a href="#ref008">otl_exception::disabled</a> <i><font color="#804000">// disable OTL exceptions</font></i>
   ); <i><font color="#804000">// drop table</font></i>

  <a href="#sec24">otl_cursor::direct_exec</a>
   (
    db,
    <font color="#008080">"create table test_tab(f1 number, f2 varchar2(30))"</font>
    );  <i><font color="#804000">// create table</font></i>

  <a href="#ref101">insert()</a>; <i><font color="#804000">// insert records into table</font></i>
  <a href="#ref102">select()</a>; <i><font color="#804000">// select records from table</font></i>

 }

 <font color="#0000A0">catch</font>(<a href="#sec23">otl_exception</a>& p){ <i><font color="#804000">// intercept OTL exceptions</font></i>
  cerr&lt;&lt;<a href="#sec23">p.msg</a>&lt;&lt;endl; <i><font color="#804000">// print out error message</font></i>
  <font color="#0000A0">if</font>(p.stm_text)
   cerr&lt;&lt;<a href="#sec23">p.stm_text</a>&lt;&lt;endl; <i><font color="#804000">// print out SQL that caused the error</font></i>
 }

 <a href="#ref009">db.logoff()</a>; <i><font color="#804000">// disconnect from Oracle</font></i>

 <font color="#0000A0">return</font> 0;

}

</pre>
<h4>Output</h4>
<pre>

f1=8, f2=Name8
f1=9, f2=Name9
f1=10, f2=Name10
f1=11, f2=Name11
f1=12, f2=Name12
f1=13, f2=Name13
f1=14, f2=Name14
f1=15, f2=Name15
f1=16, f2=Name16
f1=4, f2=Name4
f1=5, f2=Name5
f1=6, f2=Name6
f1=7, f2=Name7
f1=8, f2=Name8

</pre>

<h3>Example 2 (with PL/SQL block)</h3>

<h4>Source code</h4>
<pre>

<font color="#FF0000">#include &lt;iostream.h&gt;</font>
<font color="#FF0000">#include &lt;stdio.h&gt;</font>
<font color="#FF0000">#include &lt;otl.h&gt;</font>

<a href="#ref002">otl_connect</a> db; <i><font color="#804000">// connect object</font></i>

<a name="ref201"></a><h4><font color="#0000A0">void</font> plsql()</h4>
<i><font color="#804000">// invoking PL/SQL block</font></i>
{ 
 <a href="#ref001">otl_stream</a> o(5, <i><font color="#804000">// buffer size</font></i>
	      <font color="#008080">"begin "</font>
	      <font color="#008080">" :A&lt;int,inout&gt; := :A+1; "</font>
	      <font color="#008080">" :B&lt;char[31],out&gt; := :C&lt;char[31],in&gt;; "</font>
	      <font color="#008080">"end;"</font>,
	         <i><font color="#804000">// PL/SQL block</font></i>
	      db <i><font color="#804000">// connect object</font></i>
	     );
 o<a href="#ref003">&lt;&lt;</a>1<a href="#ref003">&lt;&lt;</a><font color="#008080">"Test String1"</font>; <i><font color="#804000">// assigning :A = 1, :C = "Test String1"</font></i>
 o<a href="#ref003">&lt;&lt;</a>2<a href="#ref003">&lt;&lt;</a><font color="#008080">"Test String2"</font>; <i><font color="#804000">// assigning :A = 2, :C = "Test String2"</font></i>
 o<a href="#ref003">&lt;&lt;</a>3<a href="#ref003">&lt;&lt;</a><font color="#008080">"Test String3"</font>; <i><font color="#804000">// assigning :A = 3, :C = "Test String3"</font></i>

 o.<a href="#ref010">flush()</a>; <i><font color="#804000">// executing PL/SQL block 3 times</font></i>

 <font color="#0000A0">int</font> a;
 <font color="#0000A0">char</font> b[32];

 <font color="#0000A0">while</font>(!o.<a href="#ref005">eof()</a>){ <i><font color="#804000">// not end-of-data</font></i>
  o<a href="#ref004">&gt;&gt;</a>a<a href="#ref004">&gt;&gt;</a>b;
  cout&lt;&lt;<font color="#008080">"A="</font>&lt;&lt;a&lt;&lt;<font color="#008080">", B="</font>&lt;&lt;b&lt;&lt;endl;
 }

}

<h4><font color="#0000A0">int</font> main()</h4>
{
 <a href="#ref006">otl_connect::otl_initialize()</a>; <i><font color="#804000">// initialize OCI environment</font></i>
 <font color="#0000A0">try</font>{
  db.<a href="#ref007">rlogon</a>(<font color="#008080">"scott/tiger"</font>); <i><font color="#804000">// connect to Oracle</font></i>
  <a href="#ref201">plsql()</a>; <i><font color="#804000">// invoking PL/SQL block</font></i>
 }
 <font color="#0000A0">catch</font>(<a href="#sec23">otl_exception</a>& p){ <i><font color="#804000">// intercept OTL exceptions</font></i>
  cerr&lt;&lt;<a href="#sec23">p.msg</a>&lt;&lt;endl; <i><font color="#804000">// print out error message</font></i>
  <font color="#0000A0">if</font>(p.stm_text)
   cerr&lt;&lt;<a href="#sec23">p.stm_text</a>&lt;&lt;endl; <i><font color="#804000">// print out SQL that caused the error</font></i>
 }
 db.<a href="#ref009">logoff()</a>; <i><font color="#804000">// disconnect from Oracle</font></i>
 <font color="#0000A0">return</font> 0;
} 

</pre>
<h4>Output</h4>
<pre>

A=2, B=Test String1
A=3, B=Test String2
A=4, B=Test String3

</pre>

<h3>Example 3 (with printf/scanf functions)</h3>

<h4>Source code</h4>
<pre>

<font color="#FF0000">#include &lt;iostream.h&gt;</font>
<font color="#FF0000">#include &lt;stdio.h&gt;</font>
<font color="#FF0000">#include &lt;otl.h&gt;</font>

<a href="#ref002">otl_connect</a> db; <i><font color="#804000">// connect object</font></i>

<a name="ref301"></a><h4><font color="#0000A0">void</font> insert()</h4>
<i><font color="#804000">// insert rows into table</font></i>
{ 
 <a href="#ref001">otl_stream</a> o(50, <i><font color="#804000">// buffer size</font></i>
	      <font color="#008080">"insert into test_tab values(:f1&lt;int&gt;,:f2&lt;char[31]&gt;)"</font>, 
	         <i><font color="#804000">// SQL statement</font></i>
	      db <i><font color="#804000">// connect object</font></i>
	     );
 <font color="#0000A0">char</font> tmp[32];

 <font color="#0000A0">for</font>(<font color="#0000A0">int</font> i=1;i&lt;=100;++i){
  sprintf(tmp,<font color="#008080">"Name%d"</font>,i);
  o.<a href="#ref011">printf</a>(<font color="#008080">"%d %s"</font>,i,tmp); <i><font color="#804000">// write one row into stream</font></i>
 }
}

<a name="ref302"></a><h4><font color="#0000A0">void</font> select()</h4>
{ 
 <a href="#ref001">otl_stream</a> i(50, <i><font color="#804000">// buffer size</font></i>
	      <font color="#008080">"select * from test_tab where f1&gt;=:f&lt;int&gt; and f1&lt;=:f*2"</font>,
	         <i><font color="#804000">// SELECT statement</font></i>
	      db <i><font color="#804000">// connect object</font></i>
	     ); 
   <i><font color="#804000">// create select stream</font></i>
 
 <font color="#0000A0">int</font> f1;
 <font color="#0000A0">char</font> f2[31];

 i<a href="#ref003">&lt;&lt;</a>8; <i><font color="#804000">// assigning :f = 8</font></i>
   <i><font color="#804000">// SELECT automatically executes when all input variables are</font></i>
   <i><font color="#804000">// assigned. First portion of out rows is fetched to the buffer</font></i>

 <font color="#0000A0">while</font>(!i.<a href="#ref005">eof()</a>){ <i><font color="#804000">// while not end-of-data</font></i>
  i.<a href="#ref011">scanf</a>(<font color="#008080">"%d %s"</font>,&f1,f2); <i><font color="#804000">// read one row from stream</font></i>
  cout&lt;&lt;<font color="#008080">"f1="</font>&lt;&lt;f1&lt;&lt;<font color="#008080">", f2="</font>&lt;&lt;f2&lt&lt;endl;
 }
 
 i<a href="#ref003">&lt;&lt;</a>4; <i><font color="#804000">// assigning :f = 4</font></i>
   <i><font color="#804000">// SELECT automatically re-executes when all input variables are</font></i>
   <i><font color="#804000">// assigned. First portion of out rows is fetched to the buffer</font></i>

 <font color="#0000A0">while</font>(!i.<a href="#ref005">eof()</a>){ <i><font color="#804000">// while not end-of-data</font></i>
  i.<a href="#ref011">scanf</a>(<font color="#008080">"%d %s"</font>,&f1,f2); <i><font color="#804000">// read one row from stream</font></i>
  cout&lt;&lt;<font color="#008080">"f1="</font>&lt;&lt;f1&lt;&lt;<font color="#008080">", f2="</font>&lt;&lt;f2&lt;&lt;endl;
 }

}

<h4><font color="#0000A0">int</font> main()</h4>
{
 <a href="#ref006">otl_connect::otl_initialize()</a>; <i><font color="#804000">// initialize OCI environment</font></i>

 <font color="#0000A0">try</font>{

  db.<a href="#ref007">rlogon</a>(<font color="#008080">"scott/tiger"</font>); <i><font color="#804000">// connect to Oracle</font></i>

  <a href="#sec24">otl_cursor::direct_exec</a>
   (
    db,
    <font color="#008080">"drop table test_tab"</font>,
    <a href="#ref008">otl_exception::disabled</a> <i><font color="#804000">// disable OTL exceptions</font></i>
   ); <i><font color="#804000">// drop table</font></i>

  <a href="#sec24">otl_cursor::direct_exec</a>
   (
    db,
    <font color="#008080">"create table test_tab(f1 number, f2 varchar2(30))"</font>
    );  <i><font color="#804000">// create table</font></i>

  <a href="#ref301">insert()</a>; <i><font color="#804000">// insert records into table</font></i>
  <a href="#ref302">select()</a>; <i><font color="#804000">// select records from table</font></i>

 }

 <font color="#0000A0">catch</font>(<a href="#sec23">otl_exception</a>& p){ <i><font color="#804000">// intercept OTL exceptions</font></i>
  cerr&lt;&lt;<a href="#sec23">p.msg</a>&lt;&lt;endl; <i><font color="#804000">// print out error message</font></i>
  <font color="#0000A0">if</font>(p.stm_text)
   cerr&lt;&lt;<a href="#sec23">p.stm_text</a>&lt;&lt;endl; <i><font color="#804000">// print out SQL that caused the error</font></i>
 }

 db.<a href="#ref009">logoff()</a>; <i><font color="#804000">// disconnect from Oracle</font></i>

 <font color="#0000A0">return</font> 0;

}

</pre>
<h4>Output</h4>
<pre>

f1=8, f2=Name8
f1=9, f2=Name9
f1=10, f2=Name10
f1=11, f2=Name11
f1=12, f2=Name12
f1=13, f2=Name13
f1=14, f2=Name14
f1=15, f2=Name15
f1=16, f2=Name16
f1=4, f2=Name4
f1=5, f2=Name5
f1=6, f2=Name6
f1=7, f2=Name7
f1=8, f2=Name8

</pre>

<h3>Example 4 (with otl_stream class and referenced cursor)</h3>
<h4>Source code</h4>
<pre>

<font color="#FF0000">#include &lt;iostream.h&gt;</font>
<font color="#FF0000">#include &lt;stdio.h&gt;</font>
<font color="#FF0000">#include &lt;otl.h&gt;</font>

<a href="#ref002">otl_connect</a> db; <i><font color="#804000">// connect object</font></i>

<a name="ref401"></a><h4><font color="#0000A0">void</font> insert()</h4>
<i><font color="#804000">// insert rows into table</font></i>
{ 
 <a href="#ref001">otl_stream</a> o(50, <i><font color="#804000">// buffer size</font></i>
	      <font color="#008080">"insert into test_tab values(:f1&lt;float&gt;,:f2&lt;char[31]&gt;)"</font>, 
	         <i><font color="#804000">// SQL statement</font></i>
	      db <i><font color="#804000">// connect object</font></i>
	     );
 <font color="#0000A0">char</font> tmp[32];

 <font color="#0000A0">for</font>(int i=1;i&lt;=100;++i){
  sprintf(tmp,<font color="#008080">"Name%d"</font>,i);
  o<a href="#ref003">&lt;&lt;</a>(<font color="#0000A0">float</font>)i<a href="#ref003">&lt;&lt;</a>tmp;
 }
}

<a name="ref402"></a><h4><font color="#0000A0">void</font> select()</h4>
{ 
 <a href="#ref001">otl_stream</a> i(50, <i><font color="#804000">// buffer size</font></i>
	      <font color="#008080">"begin "</font>
              <font color="#008080">" open :cur for "</font>
              <font color="#008080">"  select * "</font>
              <font color="#008080">"  from test_tab "</font>
              <font color="#008080">"  where f1&gt;=:f&lt;int&gt; and f1&lt;=:f*2; "</font>
              <font color="#008080">"end;"</font>, 
	         <i><font color="#804000">// PL/SQL block returns a referenced cursor</font></i>
	      db, <i><font color="#804000">// connect object</font></i>
              <font color="#008080">":cur"</font> <i><font color="#804000">// referenced cursor placeholder name</font></i>
	     ); 
   <i><font color="#804000">// create select stream</font></i>
 
 <font color="#0000A0">int</font> f1;
 <font color="#0000A0">char</font> f2[31];

 i<a href="#ref003">&lt;&lt;</a>8; <i><font color="#804000">// assigning :f = 8</font></i>
   <i><font color="#804000">// SELECT automatically executes when all input variables are</font></i>
   <i><font color="#804000">// assigned. First portion of out rows is fetched to the buffer</font></i>

 <font color="#0000A0">while</font>(!i.<a href="#ref005">eof()</a>){ <i><font color="#804000">// while not end-of-data</font></i>
  i<a href="#ref004">&gt;&gt;</a>f1<a href="#ref004">&gt;&gt;</a>f2;
  cout&lt;&lt;<font color="#008080">"f1="</font>&lt;&lt;f1&lt;&lt;<font color="#008080">", f2="</font>&lt;&lt;f2&lt;&lt;endl;
 }
 
 i<a href="#ref003">&lt;&lt;</a>4; <i><font color="#804000">// assigning :f = 4</font></i>
   <i><font color="#804000">// SELECT automatically re-executes when all input variables are</font></i>
   <i><font color="#804000">// assigned. First portion of out rows is fetched to the buffer</font></i>

 <font color="#0000A0">while</font>(!i.<a href="#ref005">eof()</a>){ <i><font color="#804000">// while not end-of-data</font></i>
  i<a href="#ref004">&gt;&gt;</a>f1<a href="#ref004">&gt;&gt;</a>f2;
  cout&lt;&lt;<font color="#008080">"f1="</font>&lt;&lt;f1&lt;&lt;<font color="#008080">", f2="</font>&lt;&lt;f2&lt;&lt;endl;
 }

}

<h4><font color="#0000A0">int</font> main()</h4>
{
 <a href="#ref006">otl_connect::otl_initialize()</a>; <i><font color="#804000">// initialize OCI environment</font></i>

 <font color="#0000A0">try</font>{

  db.<a href="#ref007">rlogon</a>(<font color="#008080">"scott/tiger"</font>); <i><font color="#804000">// connect to Oracle</font></i>

  <a href="#sec24">otl_cursor::direct_exec</a>
   (
    db,
    <font color="#008080">"drop table test_tab"</font>,
    <a href="#ref008">otl_exception::disabled</a> <i><font color="#804000">// disable OTL exceptions</font></i>
   ); <i><font color="#804000">// drop table</font></i>

  <a href="#sec24">otl_cursor::direct_exec</a>
   (
    db,
    <font color="#008080">"create table test_tab(f1 number, f2 varchar2(30))"</font>
    );  <i><font color="#804000">// create table</font></i>

  <a href="#ref401">insert()</a>; <i><font color="#804000">// insert records into table</font></i>
  <a href="#ref402">select()</a>; <i><font color="#804000">// select records from table</font></i>

 }

 <font color="#0000A0">catch</font>(<a href="#sec23">otl_exception</a>& p){ <i><font color="#804000">// intercept OTL exceptions</font></i>
  cerr&lt;&lt;<a href="#sec23">p.msg</a>&lt;&lt;endl; <i><font color="#804000">// print out error message</font></i>
  <font color="#0000A0">if</font>(p.stm_text)
   cerr&lt;&lt;<a href="#sec23">p.stm_text</a>&lt;&lt;endl; <i><font color="#804000">// print out SQL that caused the error</font></i>
 }

 db.<a href="#ref009">logoff()</a>; <i><font color="#804000">// disconnect from Oracle</font></i>

 <font color="#0000A0">return</font> 0;

}

</pre>
<h4>Output</h4>
<pre>

f1=8, f2=Name8
f1=9, f2=Name9
f1=10, f2=Name10
f1=11, f2=Name11
f1=12, f2=Name12
f1=13, f2=Name13
f1=14, f2=Name14
f1=15, f2=Name15
f1=16, f2=Name16
f1=4, f2=Name4
f1=5, f2=Name5
f1=6, f2=Name6
f1=7, f2=Name7
f1=8, f2=Name8

</pre>

<h1><a name="sec3">3. STL-compliant iterators for otl_stream </h1>
<p>
OTL provides two <a href="#sec22">otl_stream</a> based <a
href="http://www.sgi.com/Technology/STL/Iterators.html">STL-compliant
iterator</a> classes:
</p>
<ul>
<li><a href="otl_it01.htm">otl_output_iterator</a></li>
<li><a href="otl_it02.htm">otl_input_iterator</a></li>
</ul>
<p>
These two iterator classes make it possible to combine the power of <a
href="http://www.metabyte.com/~fbp/stl/readings.html">generic
programming</a> and Oracle into compact, reliable, top performance and
easy-to-maintain C++ database applications.
</p>
<p>
It would be cool to develop a PL/SQL-to-C++ converter which would
use STL container classes (to efficiently implement PL/SQL tables) and
OTL to take advantage of straight OCI in order to efficiently
implement Oracle cursor handling. Also, converting interpreted code
into code compiled into native machine instructions is not such a bad
idea. 
</p>

<h2><a name="sec31">3.1. Example </h2>

<h4>Source code</h4>
<pre>

<font color="#FF0000">#include &lt;iostream.h&gt;</font>
<font color="#FF0000">#include &lt;stdio.h&gt;</font>
<font color="#FF0000">#include &lt;otl_iter.h&gt;</font>
<font color="#FF0000">#include &lt;vector.h&gt;</font>
<font color="#FF0000">#include &lt;hash_map.h&gt;</font>
<font color="#FF0000">#include &lt;iterator.h&gt;</font>

<a href="#ref002">otl_connect</a> db; <i><font color="#804000">// connect object</font></i>

<i><font color="#804000">// row container class</font></i>
<font color="#0000A0">class</font> row{
<font color="#0000A0">public</font>:
 <font color="#0000A0">int</font> f1;
 <font color="#0000A0">char</font> f2[32];

<i><font color="#804000">// default constructor</font></i>
 row(){f1=0; f2[0]=0;}

<i><font color="#804000">// destructor</font></i>
 ~row(){}

<i><font color="#804000">// copy constructor</font></i>
 row(<font color="#0000A0">const</font> row& row)
 {
  f1=row.f1;
  strcpy(f2,row.f2);
 }
 
<i><font color="#804000">// assignment operator</font></i>
 row& <font color="#0000A0">operator</font>=(<font color="#0000A0">const</font> row& row)
 {
  f1=row.f1;
  strcpy(f2,row.f2);
  <font color="#0000A0">return</font> *<font color="#0000A0">this</font>;
 }

};

<i><font color="#804000">// redefined operator&gt;&gt; for reading row& from otl_stream</font></i>
<a href="#ref001">otl_stream</a>& <font color="#0000A0">operator</font>&gt;&gt;(<a href="#ref001">otl_stream</a>& s, row& row)
{
 s<a href="#ref004">&gt;&gt;</a>row.f1<a href="#ref004">&gt;&gt;</a>row.f2;
 <font color="#0000A0">return</font> s;
}

<i><font color="#804000">// redefined operator&lt;&lt; for writing row& into otl_stream</font></i>
<a href="#ref001">otl_stream</a>& <font color="#0000A0">operator</font>&lt;&lt;(<a href="#ref001">otl_stream</a>& s, <font color="#0000A0">const</font> row& row)
{
 s<a href="#ref003">&lt;&lt;</a>row.f1<a href="#ref003">&lt;&lt;</a>row.f2;
 <font color="#0000A0">return</font> s;
}

<i><font color="#804000">// redefined operator&lt;&lt; writing row& into ostream</font></i>
ostream& <font color="#0000A0">operator</font>&lt;&lt;(ostream& s, <font color="#0000A0">const</font> row& row)
{
 s&lt;&lt;<font color="#008080">"f1="</font>&lt;&lt;row.f1&lt;&lt;<font color="#008080">", f2="</font>&lt;&lt;row.f2;
 <font color="#0000A0">return</font> s;
}

<a name="ref501"></a><h4><font color="#0000A0">void</font> insert()</h4>
<i><font color="#804000">// insert rows into table</font></i>
{ 
 <a href="#ref001">otl_stream</a> o(50, <i><font color="#804000">// buffer size</font></i>
	      <font color="#008080">"insert into test_tab values(:f1&lt;int&gt;,:f2&lt;char[31]&gt;)"</font>, 
	         <i><font color="#804000">// SQL statement</font></i>
	      db // connect object
	     );
 row r; <i><font color="#804000">// single row buffer</font></i>
 vector&lt;row&gt; vo; <i><font color="#804000">// vector of rows</font></i>

<i><font color="#804000">// populate the vector</font></i>
 <font color="#0000A0">for</font>(<font color="#0000A0">int</font> i=1;i<=100;++i){
  r.f1=i;
  sprintf(r.f2,<font color="#008080">"Name%d"</font>,i);
  vo.push_back(r);
 }

 cout&lt;&lt;<font color="#008080">"vo.size="</font>&lt;&lt;vo.size()&lt;&lt;endl;
<i><font color="#804000">// insert vector into table</font></i>
 copy(vo.begin(), 
      vo.end(), 
      <a href="otl_it01.htm#">otl_output_iterator</a>&lt;row&gt;(o)
     );

}

<a name="ref502"></a><h4><font color="#0000A0">void</font> select()</h4>
{ 
 <a href="#ref001">otl_stream</a> i(50, <i><font color="#804000">// buffer size</font></i>
	      <font color="#008080">"select * from test_tab where f1>=:f&lt;int&gt; and f1&lt;=:f*2"</font>,
	         <i><font color="#804000">// SELECT statement</font></i>
	      db <i><font color="#804000">// connect object</font></i>
	     ); 
   <i><font color="#804000">// create select stream</font></i>
 
 vector&lt;int&gt; inp_par; <i><font color="#804000">// vector of 1 element to demonstrate OTL iterators</font></i>
 vector&lt;row&gt; v; <i><font color="#804000">// vector of rows</font></i>

<i><font color="#804000">// assigning :f = 8</font></i>
<i><font color="#804000">// this example demonstrates how both input</font></i>
<i><font color="#804000">// and output iterators may be attached to the</font></i>
<i><font color="#804000">// same otl_stream</font></i>

 inp_par.push_back(8); <i><font color="#804000">// populate the vector with one element</font></i>
 cout&lt;&lt;<font color="#008080">"inp_par.size="</font>&lt;&lt;inp_par.size()&lt;&lt;endl;

<i><font color="#804000">// copy the vector into the input variable of the select statement</font></i>
 copy(inp_par.begin(),inp_par.end(),<a href="otl_it01.htm#">otl_output_iterator</a>&lt;int&gt;(i));

<i><font color="#804000"> // SELECT automatically executes when all input variables are</font></i>
<i><font color="#804000"> // assigned. First portion of out rows is fetched to the buffer</font></i>

<i><font color="#804000">// copy all rows to be fetched into the vector</font></i>

 copy(<a href="otl_it02.htm#">otl_input_iterator</a>&lt;row,ptrdiff_t&gt;(i), 
      <a href="otl_it02.htm#">otl_input_iterator</a>&lt;row,ptrdiff_t&gt;(),
      back_inserter(v));    

 cout&lt;&lt;<font color="#008080">"Size="</font>&lt;&lt;v.size()&lt;&lt;endl;

<i><font color="#804000">// send the vector to cout</font></i>
 copy(v.begin(), v.end(), ostream_iterator&lt;row&gt;(cout, <font color="#008080">"\n"</font>));

<i><font color="#804000">// clean up the vector</font></i>
 v.erase(v.begin(),v.end());

<i><font color="#804000">// OTL traditional technique</font></i>
  i<a href="#ref003">&lt;&lt;</a>4; <i><font color="#804000">// assigning :f = 4</font></i>
<i><font color="#804000">   // SELECT automatically executes when all input variables are</font></i>
<i><font color="#804000">   // assigned. First portion of out rows is fetched to the buffer</font></i>

<i><font color="#804000">// copy all rows to be fetched to the vector</font></i>
 copy(otl_input_iterator&lt;row,ptrdiff_t&gt;(i), 
      otl_input_iterator&lt;row,ptrdiff_t&gt;(),
      back_inserter(v));    

 cout&lt;&lt;<font color="#008080">"Size="</font>&lt;&lt;v.size()&lt;&lt;endl;

<i><font color="#804000">// send the vector to cout</font></i>
 copy(v.begin(), v.end(), ostream_iterator&lt;row&gt;(cout, <font color="#008080">"\n"</font>));

}

<h4><font color="#0000A0">int</font> main()</h4>
{
 <a href="#ref006">otl_connect::otl_initialize()</a>; <i><font color="#804000">// initialize OCI environment</font></i>

 <font color="#0000A0">try</font>{

  db.<a href="#ref007">rlogon</a>(<font color="#008080">"scott/tiger"</font>); <i><font color="#804000">// connect to Oracle</font></i>

  <a href="#sec24">otl_cursor::direct_exec</a>
   (db,
    <font color="#008080">"drop table test_tab"</font>,
    otl_exception::disabled <i><font color="#804000">// disable OTL exceptions</font></i>
   ); <i><font color="#804000">// drop table</font></i>

  <a href="#sec24">otl_cursor::direct_exec</a>
   (db,
    <font color="#008080">"create table test_tab(f1 number, f2 varchar2(30))"</font>
   );  <i><font color="#804000">// create table</font></i>

  <a href="#ref501">insert()</a>; <i><font color="#804000">// insert records into table</font></i>
  <a href="#ref502">select()</a>; <i><font color="#804000">// select records from table</font></i>

 }

 <font color="#0000A0">catch</font>(<a href="#sec23">otl_exception</a>& p){ <i><font color="#804000">// intercept OTL exceptions</font></i>
  cerr&lt;&lt;<a href="#sec23">p.msg</a>&lt;&lt;endl; <i><font color="#804000">// print out error message</font></i>
  <font color="#0000A0">if</font>(p.stm_text)
   cerr&lt;&lt;<a href="#sec23">p.stm_text</a>&lt;&lt;endl; <i><font color="#804000">// print out SQL statement associated with the error</font></i>
 }

 db.<a href="#ref009">logoff(</a>); <i><font color="#804000">// disconnect from Oracle</font></i>

 <font color="#0000A0">return</font> 0;

}

</pre>
<h4>Output</h4>
<xmp>

vo.size=100
inp_par.size=1
Size=9
f1=8, f2=Name8
f1=9, f2=Name9
f1=10, f2=Name10
f1=11, f2=Name11
f1=12, f2=Name12
f1=13, f2=Name13
f1=14, f2=Name14
f1=15, f2=Name15
f1=16, f2=Name16
Size=5
f1=4, f2=Name4
f1=5, f2=Name5
f1=6, f2=Name6
f1=7, f2=Name7
f1=8, f2=Name8

</xmp>


<h1><a name="app_a">Appendix A. How to download the source code</h1>

<P>In order to obtain a copy of the OTL header files, send email to <A HREF="mailto:skuchin@ispwest.com">skuchin@ispwest.com</A>,
<A HREF="mailto:skuchin@gmail.com">skuchin@gmail.comgmail</P>

<P>Here is the list of the OTL header files:</P>

<UL>
<LI><I><FONT COLOR="#804040">otl7.h</FONT></I> -- the OTL source code for
Oracle 7. </LI>

<LI><I><FONT COLOR="#804040">otl8.h</FONT></I> -- the OTL source code for
Oracle 8. Save the file as otl.h. </LI>

<LI><I><FONT COLOR="#804040">otl_iter.h</FONT></I> -- STL-compliant iterators
for otl_stream </LI>
</UL>

<p>
Besides, you need to have standard OCI header files and object
libraries. The location of the files and libraries is specific to the
operating system. See the Oracle manuals for more details. 
</p>
<p>
The OCI7 standard header files are as follows:
<ul>
<li>ociapr.h</li>
<li>ocidfn.h</li>
<li>ocikpr.h</li>
<li>oratypes.h</li>
</ul>
</p>
<p>
The OCI8 standard header files are as follows:
<ul>
<li>nzerror.h</li>
<li>nzt.h</li>
<li>oci.h</li>
<li>ociap.h</li>
<li>ociapr.h</li>
<li>ocidef.h</li>
<li>ocidem.h</li>
<li>ocidfn.h</li>
<li>ociextp.h</li>
<li>ocikp.h</li>
<li>ocikpr.h</li>
<li>oratypes.h</li>
<li>ori.h</li>
<li>orid.h</li>
<li>orl.h</li>
<li>oro.h</li>
<li>ort.h</li>
<li>tnsapi.h</li>
</ul>
</p>
<p>
If you want to use the <a href="#sec3">STL-compliant iterators</a>
then you are going to need the <a
href="http://www.metabyte.com/~fbp/stl/">Standard Template Library</a>
(adaption by <a href="mailto:fbp@metabyte.com">Boris Fomitchev</a>) or <a
href="http://www.sgi.com/Technology/STL/">the original STL SGI, version 3.11</a>.
</p>

<h1><a name="app_b">Appendix B. OTL exception list</h2>

<p>
The following <a href="#sec23">OTL exceptions</a> can be raised by the
OTL functions:
</p>
<dl>
<dt><b>Code=32000</b>: Incompatible data types in stream operation
<dd><br>
           <b>Cause</b>: The data type of a variable used in the current
           stream operation is not compatible with the declared stream
           format.
<br><br>
           <b>Action</b>: Check placeholders and their data types
           declaration.
<dt><br><b>Code=32001</b>: Row must be full for flushing output stream
<dd><br>
           <b>Cause</b>: Stream is open for output and has a format of
           output rows. An output row is a tuple of all output
           variables put together. The current output row is not
           filled yet but the flush function is invoked.  The stream
           buffer cannot be flushed until the current row of the
           output buffer is full.
<br><br>
           <b>Action</b>: Fill the row first, then flush the stream.
<dt><br><b>Code=32004</b>: Not all input variables have been initialized
<dd><br>
           <b>Cause</b>: stream has input variables but not all
           the variables have been initialized. An attempt to read
           data from the stream was made.
<br><br>
           <b>Action</b>: Assign all the input variables first.
<dt><br><b>Code=32004</b>: No input variables have been defined in SQL statement
<dd><br>
           <b>Cause</b>: Stream has no input variables. An attempt
           to write objects to the stream via one of the << operators
           was made.
<br><br>
           <b>Action</b>: Do not call the << operators for streams
           which have no input variables defined.
</dl>


</body>
</html>

