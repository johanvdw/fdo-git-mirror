<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <meta name="Author" content="Sergei Kuchin">
  <meta name="GENERATOR"
 content="Mozilla/4.78 [en] (Windows NT 5.0; U) [Netscape]">
  <meta name="KeyWords"
 content="OTL, Oracle, ODBC, DB2, CLI, database API, C++, Template Library">
  <title>OTL 4.0, OTL stream class</title>
</head>
<body>
<center>
<h1>OTL 4.0, OTL stream class</h1>
</center>
<h1>
<a name="otl_stream_class"></a>OTL stream class</h1>
The otl_strean class is the actual implemention the <a
 href="otl3_str.htm">OTL
stream concept</a>. Any SQL statement, anonymous PL/SQL block or stored
procedure with input and/or output parameters can be programmed in C++
with the otl_stream class.
<p>Traditionally, a database API has functions to bind host variables
with
placeholders in the SQL statement. So, the developer has to declare
host
arrays in the program, parse the statement, call the bind functions,
fill
out the input variables, execute the statement, read the output
variables,
etc. After the cycle is done, again, fill out the input variables,
execute
the statement, read the output. All that is done automatically in the
otl_stream
class. The class provides full automation of interaction with the
database
as well as performance. Performance is controlled by a single parameter
-- the stream&nbsp;<a name="buffer_size"></a><i>buffer size. </i>The
buffer size is defined in logical rows to inserted into a table,
selected from a table / view in one round-trip to the database (a.k.a.
batch size, array size).<br>
</p>
<p>A SQL statement in the otl_stream needs to have at least one <a
 href="otl3_bind_variables.htm">placeholder
/ bind variable</a>. SQL statements without placeholders are referred
to
as <a href="otl3_const_sql.htm">constant SQL statements.</a> and
processed
differently.<br>
</p>
<p>Starting with OTL 4.0.115 and on, the buffer size datatype is <span
 style="font-style: italic;">int </span>(the old datatype was <span
 style="font-style: italic;">short int</span>). If the old datatype is
needed for backward compatibility, #define <a
 href="otl3_compile.htm#OTL_STREAM_LEGACY_BUFFER_SIZE_TYPE">OTL_STREAM_LEGACY_BUFFER_SIZE_TYPE</a>
has to be enabled.<br>
</p>
<p>
</p>
<p>The otl_stream class has the following structure:
</p>
<pre><font size="+2">class otl_stream {<br>public:</font></pre>
<ul>
  <li>General constructor. This constructor creates an otl_stream
object and
then calls the <a href="#open">open()</a> function. There two flavors
of
the otl_streams:</li>
  <br>
  <b>for Oracle 7/8/9/10:</b>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="otl_stream_otl_stream"></a>otl_stream(const int arr_size, // stream <a
 href="#buffer_size">buffer size<br></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char* sqlstm, // SQL statement or anynonymous PL/SQL block<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
 href="otl3_connect_class.htm">otl_connect</a>&amp; db, // OTL connect object<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a
 name="ref_cur"></a>const char* ref_cur_placeholder=0,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // If the stream returns a referenced cursor,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // this parameter is used to specify the name of the&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // referenced cursor placeholder.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char* sqlstm_label=0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // SQL statement label. When specified, it is used<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // to populate <a
 href="otl3_exception_class.htm#stm_text">otl_exception::stm_text</a> with, so<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the actual text of the SQL statement will not be visible<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // and will be replaced with its label.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</pre>
<ul>
  <b>for ODBC/DB2-CLI:</b>
  <pre>otl_stream(const int arr_size, // stream <a href="#buffer_size">buffer size<br></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char* sqlstm, // SQL statement or stored procedure call<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
 href="otl3_connect_class.htm">otl_connect</a>&amp; db, // connect object<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const int implicit_select=otl_explicit_select,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // If the stream returns a result set via a strored&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // procedure call, this parameter needs to be set to&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // otl_implicit_select<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char* sqlstm_label=0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // SQL statement label. When specified, it is used<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // to populate <a
 href="otl3_exception_class.htm#stm_text">otl_exception::stm_text</a> with, so<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the actual text of the SQL statement will not be visible<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // and will be replaced with its label.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</pre>
  <a name="implicit_select"></a><font size="-1">OTL 4.0/ODBC and OTL
4.0/DB2-CLI
define the following global constant to be used with this constructor:</font>
  <ul>
    <li> <font size="-1"><b>otl_explicit_select</b> -- to indicate
that if
the stream
is a SELECT statement then the statement is a simple SELECT.</font></li>
    <li> <font size="-1"><b>otl_implicit_select</b> -- to indicate
that
the stream
is a stored procedure call that returns a result set.</font></li>
  </ul>
</ul>
<ul>
  <a name="open"></a>This function opens the SQL statement: the
statement
gets parsed, all input and output <a href="otl3_bind_variables.htm">variables</a>
get dynamically allocated inside the stream and automatically bound to
the placeholders. There are two flavors of the function: <br>
&nbsp;
  <p><b>For Oracle 7/8/9/10:</b></p>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="otl_stream_open"></a>void open(const int arr_size, // stream <a
 href="#buffer_size">buffer size<br></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char* sqlstm, // SQL statemnet or anynonymous PL/SQL block<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
 href="otl3_connect_class.htm">otl_connect</a>&amp; db, // connect object<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char* ref_cur_placeholder=0,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // If the stream returns a referenced cursor,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // this parameter is used to specify the name of the&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // referenced cursor placeholder.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char* sqlstm_label=0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // SQL statement label. When specified, it is used<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // to populate <a
 href="otl3_exception_class.htm#stm_text">otl_exception::stm_text</a> with, so<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the actual text of the SQL statement will not be visible<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // and will be replaced with its label.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</pre>
<ul>
  <pre><b>For ODBC/DB2-CLI:</b></pre>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp; void open(const int arr_size, // stream <a
 href="#buffer_size">buffer size<br></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char* sqlstm, // SQL statemnet or stored procedure call<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
 href="otl3_connect_class.htm">otl_connect</a>&amp; db, // connect object<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const int implicit_select=otl_explicit_select,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // If the stream returns a result set via a strored&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // procedure call, this parameter needs to be set to&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // otl_implicit_select<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char* sqlstm_label=0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // SQL statement label. When specified, it is used<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // to populate <a
 href="otl3_exception_class.htm#stm_text">otl_exception::stm_text</a> with, so<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the actual text of the SQL statement will not be visible<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // and will be replaced with its label.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</pre>
<ul>
  <li><a name="eof"></a>Test if all data has been already read from the
stream. This
function
has
the same meaning as the eof() funtion in C++ streams</li>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp; int eof(void);<br><br></pre>
<ul>
  <li><a name="setBufSize"></a>Set the stream buffer size. The only
thing that this function does is saves a new buffer size for further
use with otl_connect::operator<a
 href="otl3_connect_class.htm#operator_gg">&gt;&gt;</a>(otl_stream&amp;).<br>
  </li>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp; int setBufSize(const int buf_size);</pre>
<ul>
  <li> <a name="flush"></a>Flush the stream output buffer. It actually
means to
execute the SQL statement in <a href="otl3_str.htm#bulk">bulk</a> as
many
times as rows entered into the stream output buffer. The stream is
automatically
flushed when the buffer gets full. This function has the same meaning
as
the flush() function in C++ streams. Also, if the stream <tt><i>auto-commi</i>t</tt>
flag is set then the stream, after flushing the output buffer, commits
the current transaction. For more detail, see the <a href="#set_commit">set_commit</a>()
function.</li>
  <br>
  <p>OTL/OCI8,8i,9i/10g has a version of the flush function with 2
parameters:
row_offset, force_flushing This version of the flush function makes the
process of, say, inserting a big batch of rows more efficient, after,
say,
duplicate rows were discovered in the batch, and an otl_exception was
raised.
For more detail, see OTL examples.</p>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp; void flush(void);<br><br>&nbsp;&nbsp;&nbsp;&nbsp; void flush // OTL/OCI8,8i,9i,10g only&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp; (const int row_offset=0, // Specify the first row in the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // stream's buffer for flushing<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const bool force_flush=false // Force flushing regardless of&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // previous errors<br>&nbsp;&nbsp;&nbsp;&nbsp; );</pre>
<ul>
  <li> <a name="get_stream_type"></a>OTL/OCI8/9/10 only. Get the OTL
stream
type.</li>
  <p><tt>&nbsp;int get_stream_type(void);</tt> </p>
  <p>The following global&nbsp; constants (int's) are defined: <br>
&nbsp; </p>
  <ul>
    <li> <a name="stream_types"></a><b><font size="-1">otl_no_stream_type</font></b>
-- stream is not instantiated with any SQL statement yet.</li>
    <li> <b><font size="-1">otl_select_stream_type</font></b> --
stream is
instantiated
with a straight SELECT statement.</li>
    <li> <b><font size="-1">otl_inout_stream_type</font></b> -- stream
is
instantiated
with an anonymous PL/SQL block which has input/output bind variables,
possibly,
parameters in a stored procedure call.</li>
    <li> <b><font size="-1">otl_refcur_stream_type</font></b> --
stream is
instantiated
with a PL/SQL block, which returns a reference cursor. In this type of
a PL/SQL block (possibly, a stored procedure call), only input bind
variables
are allowed. The output of the PL/SQL block is the reference cursor
itself.</li>
    <li> <b><font size="-1">otl_constant_sql_type</font></b> --
special
constant that
is only used in <tt><a href="#create_stored_proc_call">create_stored_proc_call()</a></tt>,
and not returned by <a href="#get_stream_type">get_stream_type</a>().
However,
the constant completes this logical group of constants, that represent
types of&nbsp; OTL streams. In the context of
create_stored_proc_call(),
this constant indicates a call to a stored procedure, which has no
parameters,
and it needs to be executed via <a href="otl3_const_sql.htm">otl_cursor::direct_exec</a>().</li>
  </ul>
</ul>
<ul>
  <li> <a name="create_stored_proc_call"></a>OTL/OCI8/9/10 only.
Create
an
otl_stream
compatible call (string) to a stored procedure by the stored procedure
name. This function is static in class and intended for some automation
in generating Oracle 8/8i/9i/10g stored procedure calls. The function
uses
Oracle system data dictionary directly (ALL_ARGUMENTS system view), in
order to retrieve information about stored procedure's parameters, and
their datatypes. Potentially, the function may raise the <a
 href="otl3_exc_list.htm">OTL
defined exceptions</a> with the following error codes: <a
 href="otl3_exc_list.htm#32014">32014</a>, <a
 href="otl3_exc_list.htm#32015">32015</a>, <a
 href="otl3_exc_list.htm#32016">32016</a>.</li>
&nbsp; <br>
  <p>The function is able to handle the following stored
procedures/functions: <br>
&nbsp; </p>
  <ul>
    <li>stored procedures / functions from PL/SQL packages only</li>
    <li>procedures / functions, whose names are not overloaded in the
package</li>
    <li>procedures / functions, with scalar input and/or output
parameters</li>
    <li>procedures / functions with scalar input parameters and one
output
reference
cursor:</li>
    <ul>
      <li>in the case of a procedure, the reference cursor should be an
OUT or
IN/OUT
parameter in the procedure</li>
      <li>in the case of a function, the reference cursor should be a
function
return
value.</li>
    </ul>
  </ul>
  <p><br>
  <tt>&nbsp;static void create_stored_proc_call</tt> <br>
  <tt>&nbsp;(otl_connect&amp; db, // connect object</tt> <br>
  <tt>&nbsp; otl_stream&amp; args_strm, // an instance of otl_stream
that is external to this</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // function. In other words,
an otl_stream variable that needs to</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // be defined externally.
The variable is used to instantiate the stream</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // with "SELECT...FROM
ALL_ARGUMENTS...",
in order for the function to</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // be able to access the
Oracle
system data dictionary. The stream gets</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // instantiated once, and
can be reused in subsequent calls to</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the function, especially,
in a high volume environment.</tt> <br>
  <tt>&nbsp; char* sql_stm, // output, otl_stream compatible SQL
statement,
which has</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// a call to the stored procedure, with all of the stored</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// proc's parameters expanded.</tt> <br>
  <tt>&nbsp; int&amp; stm_type, // output, stream/statement <a
 href="#stream_types">type</a></tt> <br>
  <tt>&nbsp; char* refcur_placeholder, // output, in case of a stored
procedure, returnig a</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // a reference cursor, this
parameter returns a "reference cursor</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // placeholder" name, that
can be used in <a href="#otl_stream_otl_stream">otl_stream::otl_stream</a>(),
or</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // in <a
 href="#otl_stream_open">otl_stream::open</a>()
calls.</tt> <br>
  <tt>&nbsp; const char* proc_name, // stored procedure name. this
should
a stored</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// procedure from a PL/SQL package</tt> <br>
  <tt>&nbsp; const char* package_name, // PL/SQL package name, which
the stored procedure</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// belongs to</tt> <br>
  <tt>&nbsp; const char* schema_name=0, // Oracle schema name, which
the stored procedure</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// and/or the PL/SQL package belong to</tt> <br>
  <tt>&nbsp; const bool schema_name_included=false, // indicator of
whether
the call to</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// the stored procedure needs to be</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// prefixed with the schema name or not</tt> <br>
  <tt>&nbsp; const int varchar_size=2001, // VARCHAR parameters in
stored
procedure</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// don't have any sizes. This parameter defines</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// what size needs to be used in the definitions</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// of :var&lt;char[XXX] bind variables.</tt> <br>
  <tt>&nbsp; const int all_num2type=<a href="#otl_var_double">otl_var_double</a>
// This parameter defines how NUMBER</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// parameters of the stored procedure</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// will mapped to the corresponding</tt> <br>
  <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// bind variable definitions.</tt> <br>
  <tt>);</tt> <br>
&nbsp;</p>
</ul>
<ul>
  <li>Clean up the stream output buffer without <a href="#flush">flushing</a>
it. The <i>clean_up_error_flag </i>parameter, if set to 1, cleans up
the
otl_stream's internal error flag that usually gets set when the stream
throws an <a href="otl3_exception_class.htm">otl_exception</a>.See
examples <a href="otl3_ex65.htm">65</a>, <a href="otl3_ex66.htm">66</a>,
    <a href="otl3_ex67.htm">67</a>
for more detail on this parameter. The main purpose for introducing
this
parameter was to provide the stream a capability to recover from
adatabase
error without closing out the stream.</li>
  <p>In OTL 4.0.6, and later, the function is extended to work with
SELECT
statements, explicit (Oracle reference cursors) and implicit (in DB2,
MS
SQL Server, or Sybase stored procedures) result sets. An unfinished
fetch
sequence can be canceled by calling the function. Also, the function
cleans
up the error flags, that get set inside the stream, in the case of,
say,
a database error.</p>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="clean"></a>void clean(const int clean_up_error_flag=0);</pre>
<ul>
  <li>Rewind the stream. If the stream does not have any input
variables,
this
function forces the stream to execute its SQL statement.</li>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp; void rewind(void);</pre>
<ul>
  <li>OTL-stream-to-int conversion operator It returns the !eof()
status of
the
stream. It allows the operators <a href="operator_gg">&gt;&gt;</a> to
return
the !EOF status of the stream, and to be used in a while() loop as
follows:</li>
</ul>
<tt><font size="-1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
while(s&gt;&gt;f1&gt;&gt;f2){</font></tt>
<br>
<tt><font size="-1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
cout&lt;&lt;"f1="&lt;&lt;f1&lt;&lt;", f2="&lt;&lt;f2&lt;&lt;endl;</font></tt>
<br>
<tt><font size="-1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</font></tt>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="operator_int"></a>operator int(void);</pre>
<ul>
  <li>OTL/ODBC, OTL/DB2-CLI only. If the stream has a running SELECT
statement,
or a call to a stored procedure that returns a result set, in one
worker
thread (not the main thread), then the statement can be asynchronously
canceled, by calling this function from another worker thread. The
actual
cancellation of the statement depends on how the SQLCancel() call
(ODBC,
or DB2-CLI) was implemented in the underlying database API. Also, the
error
code, that otl_exception gets initialized with, depends on the
underlying
database API. In some cases, the error code is 0, but an otl_exception
gets thrown, right after the SQLCancel call returns.</li>
  <p>OTL/OCI8,8i,9i,10g have a similar function but at the level of
otl_connect: <a href="otl3_connect_class.htm#cancel">cancel</a>(). OCI
and
ODBC/DB2-CLI
are different in that regard.</p>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="cancel"></a>void cancel(void);</pre>
<ul>
  <li>Test if NULL was fetched from the stream</li>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="is_null"></a>int is_null(void);</pre>
<ul>
  <li>Set the <a href="otl3_lob_stream.htm">LOB stream mode</a>. This
function
sets the "lob stream mode" flag in the otl_stream, that is, this tells
the otl_stream that <a href="otl3_lob_stream.htm">otl_lob_stream</a>
operations
will be used. It is not required that this function be used in case of
OTL/OCI8. For OTL/ODBC and OTL/DB2-CLI, or when the <a
 href="otl4_stream_read_iterator.htm">otl_stream_read_iterator</a> is
used, it is required. However, for
writing
portable [across multiple database] code, the function should be called.</li>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="set_lob_stream_mode"></a>void set_lob_stream_mode(const bool mode=false);</pre>
<ul>
  <li>Get the <i>ROWS PROCESSED COUNT </i>(RPC). The count is defined
for
INSERT,
UPDATE, DELETE statements, and it shows how rows have been processed in
the last execution of the statement. For INSERT statements, it may be
less
or equal to the stream <a href="#buffer_size">buffer size</a>.For
DELETE
or UPDATE statements, it may be anything, depending upon what how may
rows
are being updated or deleted.</li>
  <p>In OTL 4.0.6 and higher, the function was extended to return an
accumulative
rows processed count for SELECT statements (all databases), reference
cursors
(Oracle), stored procedures that return implicit result sets.</p>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="get_rpc"></a>long get_rpc(void);</pre>
<blockquote>There is a substantial difference in the way the get_rpc()
function works in Oracle and ODBC, or DB2-CLI, in the case of an error,
when the underlying INSERT/UPDATE/DELETE statement errored out with an
otl_exception. In Oracle, in case of error, get_rpc() returns a number
of successfully processed rows, so it's easy to calculate which row
caused
the error. In ODBC, or DB2-CLI, the behavior of the SQLGetRowCount()
function
is undefined, so get_rpc() always returns 0.
  <p><i>Conclusion: </i>for portable, muti-database OTL based code,
it's
not recommended to use the database specific behavior of the get_rpc()
function. For Oracle OTL based code, it's okay to use it, since this
kind
of behavior is consistent with all versions of Oracle, that are
supported
by OTL.</p>
</blockquote>
<ul>
  <li> <a name="set_commit"></a>Set the stream <i>auto-commit</i>
flag.
When the
output buffer is <a href="#flush">flushed</a>, the current transaction
is automatically commited, if the flag is set. By default, the flag is
set. In order to prevent the current transaction from
"auto-committing",
unset the flag using this function. The stream auto-commit flag has
nothing
to do with the database auto-commit mode. The auto-commit is specific
to
the otl_stream class.</li>
  <p><a name="nocommit"></a>If it is more convenient to have the stream
"auto-commit
off" by default, then the <font size="+1">otl_nocommit_stream </font>can
be used. otl_nocommit_stream is a class derived directly from
otl_stream
with <i>auto-commit</i> turned off by default, so it does not commit
transactions. </p>
  <pre>&nbsp;&nbsp;&nbsp;&nbsp; void set_commit(int auto_commit=0);</pre>
</ul>
<ul>
  <li> <a name="set_flush"></a>Set the stream's <i>auto-flush</i>
flag.
Default
value is <i>true</i>. By default, the stream's destructor tries to
flush
the buffer, if the buffer is <i>dirty</i>. It is called <i>auto-flushing</i>.
The auto-flushing can be turned off or on explicitly with the help of
the
set_flush() function (see below). If the auto-flush flag was turned
off,
the stream's buffer needs to be flushed either by calling the
otl_stream::close()
function or the otl_stream::flush() function, because the destructor
would
not flush even if the <i>dirty </i>flag is true. This function could
be
especially useful, when OTL is used in the environment with exceptions
get thrown left and right, to prevent the otl_stream's destructor from
auto-flushing the buffer in the stack unwinding.</li>
  <p>This function disables ONLY auto-flushing in the otl_stream
destructor,
not the buffer flushing in general. When the stream buffer gets full,
it
gets flushed automatically REGARDLESS. If set_flush(false) call was
made,
it disables the automatic buffer flushing ONLY in the DESTRUCTOR, in
order
to prevent potential cascading otl_exception's.</p>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp; void set_flush(const bool auto_flush=true);</pre>
<ul>
  <li> <a name="describe_vars"></a>A group of functions for describing
otl_stream's
bind variables, both <i>input</i> and <i>output</i>. The functions
return
a pointer to the otl_var_desc structure:</li>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="otl_var_desc"></a>class otl_var_desc{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp; param_type; // 0 - IN variable, 1 - OUT variable, 2 - INOUT variable<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp; ftype; // see the <a
 href="#otl_var_dbtype">OTL codes for mapped datatypes<br></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp; elem_size; // [array] element size in bytes.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp; array_size; // array size, in case if the variable is scalar, the size<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // is equal to 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp; pos;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // In SELECT statements, pos shows a relative position<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // of the output column: 1,2,3,...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp; name_pos;&nbsp;&nbsp; // In case if the variable is defined via the placeholder<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // notation (:var&lt;...&gt;), name_pos shows a relative position<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // of the variable in the arrays of varaibles: 0,1,2,...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char name[128]; // First 127 bytes of the variable name, in case if the&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // variable was defined as a placeholder.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp; pl_tab_flag; // In OTL/OCIx, this field is equal to 1 in case if the&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // variable is defined as a PL/SQL table, 0 - otherwise.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</pre>
<ul>
  <ul>
    <li>&nbsp;Describe OUT variables. <i>desc_len</i> returns the size
of the
array
of otl_var_desc structures. The function returns a pointer to the array
of OUT variable descriptors. In case if the SQL statement does not
contain
any output variables, the functions returns 0. If a variable was
declared
as INOUT, it is presented as part of the array of the variable
descriptors,
returned by this function.</li>
    <p>OUT variables are the variables that get read FROM the stream.</p>
  </ul>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a
 name="describe_out_vars"></a><a href="#otl_var_desc">otl_var_desc</a>* describe_out_vars(int&amp; desc_len);</pre>
<ul>
  <ul>
    <li>&nbsp;Describe IN variables. <i>desc_len</i> returns the size
of the
array
of otl_var_desc structures. The function returns a pointer to the array
of IN variable descriptors. In case if the SQL statement does not
contain
any input variables, the functions returns 0. If a variable was
declared
as INOUT, it is presented as part of the array of the variable
descriptors,
returned by this function.</li>
    <br>
IN variables are the variables that get written TO the stream.
  </ul>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a
 name="describe_in_vars"></a><a href="#otl_var_desc">otl_var_desc</a>* describe_in_vars(int&amp; desc_len);</pre>
<ul>
  <ul>
    <li>&nbsp;Describe <i>next</i> output variable. Next means "next
to be
read
from the stream." That is, before calling one of
otl_stream::operator&lt;&lt;(),
sometimes it is necessary to know what is the type of the next variable
to be read. In case if the stream does not have any output variables,
the
function returns 0.</li>
  </ul>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a
 name="describe_next_out_var"></a><a href="#otl_var_desc">otl_var_desc</a>* describe_next_out_var(void);</pre>
<ul>
  <ul>
    <li>&nbsp;Describe <i>next</i> input variable. Next means "next to
be
written
to the stream." That is, before calling one of
otl_stream::operator&gt;&gt;(),
sometimes it is necessary to know what is the type of the next variable
to be written. In case if the stream does not have any input variables,
the function returns 0.</li>
  </ul>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a
 name="describe_next_in_var"></a><a href="#otl_var_desc">otl_var_desc</a>* describe_next_in_var(void);</pre>
<ul>
  <li> <a name="close"></a>Close the stream. This function has the
same
meaning
as the close() function in C++ streams. The close() function has two
implemenations:
the ordinary one <i>(1)</i>, and the extended one <i>(2)</i>, under
#define <a href="otl3_compile.htm#OTL_STREAM_POOLING_ON">OTL_STREAM_POOLING_ON</a>.</li>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp; <i>(1)</i> void close(void);</pre>
<ul>
  <i>save_in_<a href="otl3_stream_pooling.htm">stream_pool</a></i> is
an initialized parameter in the function. When it's set to <i>true</i>,
and if #define OTL_STREAM_POOLING_ON is on, the stream doesn't really
get
closed. The stream gets saved to the pool of unused OTL streams, which
can be reused later, when a similar stream (SQL statement + buffer
size)
gets opened again. The maximum size of the OTL stream pool can be set
by
otl_connect::<a href="otl3_connect_class.htm#set_stream_pool_size">set_stream_pool_size</a>().
  <p>When the save_in_stream_pool parameter is set to <i>false</i>,
the stream
DOES get closed, and doesn't get saved in any stream pool. This setting
of the parameter can be used to override the default behavior of the
otl_stream
under #define OTL_STREAM_POOLING_ON. For example, a stream with huge
SQL
statement and big buffers, which would be are a drag of the system
resources,
and would need to be deallocated as soon as the use of the stream is
finished. </p>
  <p>For more detail, see examples <a href="otl3_ex113.htm">113</a>, <a
 href="otl3_ex114.htm">114</a>, <a href="otl3_ex115.htm">115</a>.</p>
</ul>
<pre>#ifdef OTL_STREAM_POOLING_ON<br>&nbsp;&nbsp;&nbsp;&nbsp; <i>(2)</i> void close(const bool save_in_stream_pool=true);<br>#endif</pre>
<ul>
  <li><a name="good"></a>Test if the stream is open. This function has
the same meaning as
the
good()
function in C++ streams.</li>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp; int good(void);</pre>
<ul>
  <li> <a name="describe_select"></a>Describe the output column list
in:</li>
</ul>
<ul>
  <ul>
    <li>straight SELECT statement (OCIx, ODBC, and DB2-CLI)</li>
    <li>Referenced cursor (OCIx)</li>
    <li>Result set returned via a stored procedure call (ODBC for MS
SQL Server
and Sybase, DB2-CLI for DB2)</li>
  </ul>
This function returns a pointer of the <a href="#otl_column_desc">otl_column_desc</a>
type to the descriptor of the output column list:
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="otl_column_desc"></a>class otl_column_desc{<br>&nbsp;&nbsp;&nbsp;&nbsp; public:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char* name; // column name<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp; dbtype; // database dependent, column datatype code.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // for more detail, see the OCIx and the ODBC manuals.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp; otl_var_dbtype; // OTL defined, column datatype code<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp; dbsize; // column length<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp; scale; // for numeric columns, column scale<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp; prec; // for numeric columns, column precision<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp; nullok; // indicator whether column is nullable or not<br><br>--<a
 name="charset_form"></a> under <a href="otl3_compile.htm#OTL_UNICODE">OTL_UNICODE</a> and <a
 href="otl3_compile.htm#OTLORA9I">OTL_ORA9I</a> / <a
 href="otl3_compile.htm#OTL_ORA10G">OTL_ORA10G</a><br><br>       int charset_form; <br>         // SQLCS_IMPLICIT (1) for on-byte character sets, <br>         // SQLCS_NCHAR (2) for NLS multi-byte character sets<br>         // 0 otherwise.<br>       int char_size; // column size in characters, not in bytes <br>                      // this column size is set to 0 for <a
 href="otl3_compile.htm#OTL_ORA8I">OTL_ORA8I</a>,<br>                      // because the corresponding attribute<br>                      // is not available in OCI8i<br><br>&nbsp;&nbsp;&nbsp;&nbsp; };</pre>
<ul>
  <a name="otl_var_dbtype"></a><font size="-1">OTL 4.0 defines the
following
datatypes which the OTL maps the native database datatypes to:<br>
  <br>
  </font>
</ul>
<table style="text-align: left; width: 100%;" border="1" cellpadding="2"
 cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;"><span
 style="font-weight: bold; font-style: italic;">OTL defined integer
constant</span><br>
      </td>
      <td style="vertical-align: top;"><span
 style="font-weight: bold; font-style: italic;">Integer code</span><br>
      </td>
      <td style="vertical-align: top;"><span
 style="font-weight: bold; font-style: italic;">Explanation</span><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><b>otl_var_bigint&nbsp;</b></font></td>
      <td style="vertical-align: top;">20<br>
      </td>
      <td style="vertical-align: top;">MS SQL
Server, DB2, MySQL, PostgreSQL, etc. BIGINT (signed 64-bit integer) type<font
 size="-1"><br>
      </font></td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><b>otl_var_blob</b></font></td>
      <td style="vertical-align: top;">12<br>
      </td>
      <td style="vertical-align: top;"><font size="-1">datatype that is
mapped
into BLOB
in Oracle 8<br>
      </font></td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><b>otl_var_char</b></font></td>
      <td style="vertical-align: top;">1<br>
      </td>
      <td style="vertical-align: top;"><font size="-1">null terminated
string<br>
      </font></td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><b>otl_var_clob&nbsp;</b></font></td>
      <td style="vertical-align: top;">11<br>
      </td>
      <td style="vertical-align: top;"><font size="-1">datatype that is
mapped
into CLOB
in Oracle 8 <br>
      </font></td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><b>otl_var_db2date&nbsp;</b></font></td>
      <td style="vertical-align: top;">17<br>
      </td>
      <td style="vertical-align: top;">DB2 DATE type<font size="-1"> <br>
      </font></td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><b>otl_var_db2time</b></font></td>
      <td style="vertical-align: top;">16<br>
      </td>
      <td style="vertical-align: top;">DB2 TIME type<font size="-1"><br>
      </font></td>
    </tr>
    <tr>
      <td style="vertical-align: top;"> <a name="otl_var_double"></a><font
 size="-1"><b>otl_var_double</b></font></td>
      <td style="vertical-align: top;">2<br>
      </td>
      <td style="vertical-align: top;"><font size="-1">8-byte
floating point number<br>
      </font></td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><b>otl_var_float</b></font></td>
      <td style="vertical-align: top;">3<br>
      </td>
      <td style="vertical-align: top;"><font size="-1">4-byte floating
point
number<br>
      </font></td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><b>otl_var_int</b></font></td>
      <td style="vertical-align: top;">4<br>
      </td>
      <td style="vertical-align: top;">signed <font size="-1">32-bit&nbsp;
integer<br>
      </font></td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><b>otl_var_long_int</b></font></td>
      <td style="vertical-align: top;">7<br>
      </td>
      <td style="vertical-align: top;"><font size="-1">signed
32-bit integer<br>
      </font></td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><b>otl_var_ltz_timestamp&nbsp;</b></font></td>
      <td style="vertical-align: top;">19<br>
      </td>
      <td style="vertical-align: top;">Oracle
9i/10g TIMESTAMP WITH LOCAL TIME ZONE type<font size="-1"><br>
      </font></td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;"><a
 name="otl_var_raw"></a>otl_var_raw</span><br>
      </td>
      <td style="vertical-align: top;">23<br>
      </td>
      <td style="vertical-align: top;">RAW, BINARY, VARBINARY, BYTEA,
VARCHAR BYTE, CHAR BYTE, etc.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><b>otl_var_raw_long</b></font></td>
      <td style="vertical-align: top;">10<br>
      </td>
      <td style="vertical-align: top;"><font size="-1">datatype that is
mapped into LONG
RAW in Oracle 7/8, IMAGE in MS SQL Server ad Sybase, BLOB in DB2<br>
      </font></td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><b>otl_var_short</b></font></td>
      <td style="vertical-align: top;">6<br>
      </td>
      <td style="vertical-align: top;">signed <font size="-1">16-bit
integer <br>
      </font></td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><b>otl_var_timestamp</b></font></td>
      <td style="vertical-align: top;">8<br>
      </td>
      <td style="vertical-align: top;"><font size="-1">datatype that is
mapped into
TIMESTAMP_STRUCT, ODBC and DB2-CLI only<br>
      </font></td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><b>otl_var_tz_timestamp</b></font></td>
      <td style="vertical-align: top;">18<br>
      </td>
      <td style="vertical-align: top;">Oracle
9i/10g TIMESTAMP WITH TIME ZONE type<font size="-1"><br>
      </font></td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><b>otl_var_unsigned_int</b></font></td>
      <td style="vertical-align: top;">5<br>
      </td>
      <td style="vertical-align: top;"><font size="-1">unsigned&nbsp; </font><font
 size="-1">32-bit
integer<br>
      </font></td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><font size="-1"><b>otl_var_varchar_long</b></font></td>
      <td style="vertical-align: top;">9<br>
      </td>
      <td style="vertical-align: top;"><font size="-1">datatype that
is
mapped into
LONG in Oracle 7/8, TEXT in MS SQL Server and Sybase, CLOB in DB2<br>
      </font></td>
    </tr>
  </tbody>
</table>
<ul>
  <font size="-1"><br>
  </font>Here is the function prototype:
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="describe_select"></a>otl_column_desc* describe_select(int&amp; desc_len);</pre>
<ul>
Besides the pointer to be returned, the function has an output
parameter: <i>desc_len. </i>The length of the output column list is
returned
via this
parameter. The pointer points to an internal structure inside the
stream
which gets deallocated at the moment of the stream desctruction, so the
user does not need to do any memory deallocation operations with the
pointer.
</ul>
<ul>
  <li>Read objects from the stream</li>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="operator_gg"></a><br><br><br>#if defined(<a
 href="otl3_compile.htm#OTL_UNICODE">OTL_UNICODE</a>)<br><br>&nbsp;&nbsp;&nbsp; // OTL_UNICODE is enabled (2-byte Unicode)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a
 name="unicode_unsigned_read"></a>otl_stream&amp; operator&gt;&gt;(unsigned char* s);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // returns a null terminated array of unsigned short's<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (double-byte Unicode characters). Therefore, "unsigned char*"&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // needs to be type cast to "unsigned short*". Also, it's recommended<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // to allocate 2 bytes per each Unicode character. For Oracle Unicode,<br>       // add extra 2 bytes per possible surrogate character.<br><br>&nbsp;&nbsp;&nbsp;&nbsp; otl_stream&amp; operator&gt;&gt;(<a
 href="otl3_long_string.htm#otl_long_unicode_string">otl_long_unicode_string</a>&amp; s);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // read the Unicode LOB from the stream<br><a
 name="unicode_gg"></a><br>  #if defined(<a
 href="otl3_compile.htm#OTL_UNICODE_CHAR_TYPE">OTL_UNICODE_CHAR_TYPE</a>)<br>     otl_stream&amp; operator&gt;&gt;(OTL_UNICODE_CHAR_TYPE&amp; c); // read Unicode character<br>     otl_stream&amp; operator&gt;&gt;(OTL_UNICODE_CHAR_TYPE* s); // read Unicode string<br>  #endif<br><a
 name="unicode_string_gg"></a><br>  #if defined(<a
 href="otl3_compile.htm#OTL_UNICODE_STRING_TYPE">OTL_UNICODE_STRING_TYPE</a>)<br>     otl_stream&amp; operator&gt;&gt;(OTL_UNICODE_STRING_TYPE&amp; s); <br>       // read Unicode string into a string class variable. VARCHAR/CHAR can be <br>       // read as well as Large Text Objects (NTEXT, CLOB, NCLOB, etc.)<br>  #endif<br><br>#else<br><br>    // default, one-byte character sets<br><br>     otl_stream&amp; operator&gt;&gt;(char&amp; c);&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp; otl_stream&amp; operator&gt;&gt;(unsigned char&amp; c);&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp; otl_stream&amp; operator&gt;&gt;(char* s);&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp; otl_stream&amp; operator&gt;&gt;(unsigned char* s);&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp; <a
 name="long_string_read"></a>otl_stream&amp; operator&gt;&gt;(<a
 href="otl3_long_string.htm">otl_long_string</a>&amp; s); // read the LOB from the stream<br>&nbsp;&nbsp;&nbsp;&nbsp; <a
 name="stl_string_read"></a>otl_stream&amp; operator&gt;&gt;(std::string&amp; s); // read the ANSI C++ std::string<br><br>#endif<br><br>&nbsp;&nbsp;&nbsp;&nbsp; otl_stream&amp; operator&gt;&gt;(int&amp; n);<br>&nbsp;&nbsp;&nbsp;&nbsp; otl_stream&amp; operator&gt;&gt;(unsigned&amp; u);<br>&nbsp;&nbsp;&nbsp;&nbsp; otl_stream&amp; operator&gt;&gt;(short&amp; sh);<br>&nbsp;&nbsp;&nbsp;&nbsp; otl_stream&amp; operator&gt;&gt;(long int&amp; l);<br>&nbsp;&nbsp;&nbsp;&nbsp; otl_stream&amp; operator&gt;&gt;(float&amp; f);<br>&nbsp;&nbsp;&nbsp;&nbsp; otl_stream&amp; operator&gt;&gt;(double&amp; d);<br>     <a
 name="64_bit_integer_write"></a>otl_stream&amp; operator&gt;&gt;(<a
 href="otl3_compile.htm#OTL_BIGINT">OTL_BIGINT</a>&amp; d); <br><span
 style="text-decoration: underline;"></span>         // when #define <a
 href="otl3_compile.htm#OTL_BIGINT">OTL_BIGINT</a> is enabled.<br>         // For ODBC drivers that do not support bigint binding <br>         // of host variables natively, this operator can convert<br>         // a numeric string value to a bigint numeric value. That is, when<br>         // a numeric value is returned from the SQL statement as a string, <br>         // this operator will convert the string to a signed 64-bit integer <br>         // in C++.<br>&nbsp;&nbsp;&nbsp;&nbsp; otl_stream&amp; operator&gt;&gt;(TIMESTAMP_STRUCT&amp; s); // read the <a
 href="otl3_bind_variables.htm#timestamp">timestamp</a> from the stream<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (OTL 4.0/ODBC and OTL 4.0/DB2-CLI&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; only)<br>&nbsp;&nbsp;&nbsp;&nbsp; otl_stream&amp; operator&gt;&gt;(<a
 href="#otl_datetime">otl_datetime</a>&amp; dt); // read date/time info from the stream<br>&nbsp;&nbsp;&nbsp;&nbsp; otl_stream&amp; operator&gt;&gt;(<a
 href="otl3_pl_tab.htm">otl_XXX_tab</a>&lt;&#8230;&gt;&amp; tab); // read PL/SQL tables from the stream (OCIx)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a
 name="stream_read_lob"></a>otl_stream&amp; operator&gt;&gt;(<a
 href="otl3_lob_stream.htm">otl_lob_stream</a>&amp; lob);&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // read reference to CLOB/BLOB/TEXT/IMAGE from otl_stream&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // into otl_lob_stream. In other words,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // initialize otl_lob_stream for reading CLOB/BLOB/TEXT/IMAGE<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // in stream mode<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a
 name="stream_read_refcur"></a>otl_stream&amp; operator&gt;&gt;(<a
 href="otl4_refcur_stream.htm">otl_refcur_stream</a>&amp; refcur);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // read a reference cursor descriptor to a variable of&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the <a
 href="otl4_refcur_stream.htm">otl_refcur_stream</a> type. That is, initialize&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // otl_refcur_stream for reading rows from the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // reference cursor.<br><br></pre>
<ul>
  <li><a name="operator_ll"></a>Write objects into the stream</li>
</ul>
<pre>#if defined(<a
 href="file:///D%7C/oscl/vc/doc/otl4/otl3_compile.htm#OTL_UNICODE">OTL_UNICODE</a>)<br><br>&nbsp;&nbsp;&nbsp; // OTL_UNICODE is enabled (2-byte Unicode)<br><br>&nbsp; <a
 name="unicode_unsigned_char_write"></a>otl_stream&amp; operator&lt;&lt;(const unsigned char* s);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // writes a null terminated array of unsigned short's<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (double-byte Unicode characters) into the stream .&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Therefore, "unsigned short*"&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // needs to be type cast to "unsigned char*". Also, it's recommended<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // to allocate 2 bytes per each Unicode character. For Oracle Unicode, <br>       // add extra 2 bytes per possible surrogate character.<br><span
 style="font-family: monospace;">&nbsp;&nbsp;&nbsp; <br>    otl_stream&amp; operator&lt;&lt;(</span><a
 style="font-family: monospace;"
 href="file:///D%7C/oscl/vc/doc/otl4/otl3_long_string.htm#otl_long_unicode_string">otl_long_unicode_string</a><span
 style="font-family: monospace;">&amp; s); </span><br
 style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // write a Unicode LOB to the stream<br><a
 name="unicode_ll"></a>  <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br></span>  #if defined(<a
 href="file:///D%7C/oscl/vc/doc/otl4/otl3_compile.htm#OTL_UNICODE_CHAR_TYPE">OTL_UNICODE_CHAR_TYPE</a>)<br>     otl_stream&amp; operator&lt;&lt;(const OTL_UNICODE_CHAR_TYPE&amp; c); // write Unicode character<br>     otl_stream&amp; operator&lt;&lt;(const OTL_UNICODE_CHAR_TYPE* s); // write Unicode string<br>  #endif<br><a
 name="unicode_string_ll"></a><br>  #if defined(<a
 href="otl3_compile.htm#OTL_UNICODE_STRING_TYPE">OTL_UNICODE_STRING_TYPE</a>)<br>     otl_stream&amp; operator&gt;&gt;(const OTL_UNICODE_STRING_TYPE&amp; s); <br>       // write Unicode string from a string class variable into the stream.<br>       // VARCHAR/CHAR can be written as well <br>       // as Large Text Objects (NTEXT, CLOB, NCLOB, etc.)<br>  #endif<br><br>#else<br><br>    // default, one-byte character sets<br><br>     otl_stream&amp; operator&lt;&lt;(const char c);<br>&nbsp;&nbsp;&nbsp;&nbsp; otl_stream&amp; operator&lt;&lt;(const unsigned char c);<br>&nbsp;&nbsp;&nbsp;&nbsp; otl_stream&amp; operator&lt;&lt;(const char* s);<br>&nbsp;&nbsp;&nbsp;&nbsp; otl_stream&amp; operator&lt;&lt;(const unsigned char* s);<br>&nbsp;&nbsp;&nbsp;&nbsp; <a
 name="long_string_write"></a>otl_stream&amp; operator&lt;&lt;(const <a
 href="otl3_long_string.htm">otl_long_string</a>&amp; d); // write the LOB into the stream<br>&nbsp;&nbsp;&nbsp;&nbsp; <a
 name="stl_string_write"></a>otl_stream&amp; operator&lt;&lt;(const std::string&amp; s);&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // write the ANSI C++ std::string.<br><br>#endif<br>&nbsp;&nbsp;&nbsp;  <br>&nbsp;&nbsp;&nbsp;&nbsp; otl_stream&amp; operator&lt;&lt;(const int n);<br>&nbsp;&nbsp;&nbsp;&nbsp; otl_stream&amp; operator&lt;&lt;(const unsigned u);<br>&nbsp;&nbsp;&nbsp;&nbsp; otl_stream&amp; operator&lt;&lt;(const short sh);<br>&nbsp;&nbsp;&nbsp;&nbsp; otl_stream&amp; operator&lt;&lt;(const long int l);<br>&nbsp;&nbsp;&nbsp;&nbsp; otl_stream&amp; operator&lt;&lt;(const float f);<br>&nbsp;&nbsp;&nbsp;&nbsp; otl_stream&amp; operator&lt;&lt;(const double d);<br>&nbsp;&nbsp;&nbsp;&nbsp; <a
 name="64_bit_integer_read"></a>otl_stream&amp; operator&lt;&lt;(const <a
 href="otl3_compile.htm#OTL_BIGINT">OTL_BIGINT</a> d); <br>         // When #define <a
 href="otl3_compile.htm#OTL_BIGINT">OTL_BIGINT</a> is enabled.<br>         // For ODBC drivers that do not support bigint binding <br>         // of host variables natively, this operator can convert<br>         // a C++ bigint numeric value to a string value. That is, when <br>         // a numeric value is being written to the stream and the<br>         // corresponding host variable has a string binding, <br>         // this operator will convert a signed 64-bit integer <br>         // in C++ to a string, which will get passed to <br>         // the SQL statement.<br>       <br>     otl_stream&amp; operator&lt;&lt;(const <a
 href="#otl_null">otl_null</a> n); // write NULL into the stream<br>&nbsp;&nbsp;&nbsp;&nbsp; otl_stream&amp; operator&lt;&lt;(const TIMESTAMP_STRUCT&amp; d); // write the <a
 href="otl3_bind_variables.htm#timestamp">timestamp</a> into the stream<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // (OTL 4.0/ODBC and OTL 4.0/DB2-CLI only)<br>&nbsp;&nbsp;&nbsp;&nbsp; otl_stream&amp; operator&lt;&lt;(const <a
 href="#otl_datetime">otl_datetime</a>&amp; dt); // write date/time info into the stream<br>&nbsp;&nbsp;&nbsp;&nbsp; otl_stream&amp; operator&lt;&lt;(const <a
 href="otl3_pl_tab.htm">otl_XXX_tab</a>&lt;&#8230;&gt;&amp; tab); // read PL/SQL tables from the stream (OCIx)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a
 name="stream_write_lob"></a>otl_stream&amp; operator&lt;&lt;(<a
 href="otl3_lob_stream.htm">otl_lob_stream</a>&amp; lob);&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // write otl_lob_stream descriptor intoto otl_stream (OCI8).<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // In other words, initialize otl_lob_stream&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // for writing CLOB/BLOB in stream mode.<span
 style="font-family: monospace;"></span><br></pre>
<ul>
  <p>OTL 4.0 defines a dummy class to allow NULLs to be written into
the
stream:</p>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a
 name="otl_null"></a>class otl_null{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; otl_null(){}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~otl_null(){}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</pre>
<ul>
OTL 4.0 also defines the otl_datetime class to allow date/time
information
to written into / read from the stream:
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="otl_datetime"></a>class otl_datetime{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int year;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int month;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int day;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int hour;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int minute;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int second;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long fraction; // second's fractional part. Equals 0 by default.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int frac_precision; // second's precision. Equals 0 by default<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #if defined(<a
 href="otl3_compile.htm#OTL_ORA_TIMESTAMP">OTL_ORA_TIMESTAMP</a>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short int tz_hour; // time zone hour<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short int tz_minute; // time zone minute<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #endif<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</pre>
<blockquote><i>Fraction</i> can be up to nine significant decimal
digits
long, depending on what the second's precision (frac_precision) is
supported
by the database (MS SQL Server down to&nbsp; milliseconds, Sybase down
to milliseconds, DB2 down to microseconds, etc.), and what precision is
specified in the timestamp datatype (Oracle 9i/10g: decimal digits in
the
range
of [1..6] digits). Fraction does not have any effect in case if the
database
supports the timestamp datatype with whole seconds only.</blockquote>
<ul>
  <li> <a name="set_all_column_types"></a>Set data types of a group of
SELECT
output columns. This function can override data types of column groups:
all numeric columns to string, all date columns to string, or the
combination
of both. <i>amask </i>parameter can be set to the following values:</li>
  <ul>
    <li>otl_all_num2str, e.g.: set_all_column_types(otl_all_num2str);</li>
    <li>otl_all_date2str, e.g.: set_all_column_types(otl_all_date2str);</li>
    <li>otl_all_num2str | otl_all_date2str, e.g.:
set_all_column_types(otl_all_num2str
| otl_all_date2str);</li>
  </ul>
  <pre>void set_all_column_types(const unsigned int amask=0);</pre>
  <li> <a name="set_column_type"></a>Set a SELECT output column
datatype.
In other
words, override the default mapping of output column datatypes.</li>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp; void set_column_type(const int column_ndx,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const int col_type,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const int col_size=0);</pre>
<blockquote><i>column_ndx</i> is the relative index of the columns in
the
query: 1,2,3...
  <p><i>col_type</i> is one of the <a href="#otl_var_dbtype">datatype
constants</a>,
defined by OTL. </p>
  <p><i>col_size</i> is the size, associated with the new datatype of
the
column. It has be to specified for the otl_var_char type only. Sizess
of
all numeric types are calculated. </p>
  <p>This function can be called for straight SELECT statements (both
Oracle
and ODBC), referenced cursor SELECT statements (Oracle), and implicit
SELECT
statements / result sets (ODBC for MS SQL Server and Sybase). </p>
  <p>The usability of this function is limited by the following
datatype
compatibility matrix. <br>
&nbsp; </p>
  <p><a name="mapping"></a><br>
&nbsp; <br>
  <table border="1" cols="3" width="100%">
    <caption><br>
    </caption><tbody>
    </tbody> <tbody>
      <tr>
        <td><b>Database&nbsp; datatype</b></td>
        <td><b>Default datatype</b></td>
        <td><b>Datatype override</b></td>
      </tr>
      <tr>
        <td>NUMBER (Oracle)</td>
        <td>otl_var_double</td>
        <td>otl_var_char, otl_var_int, otl_var_float, otl_var_short,
otl_var_unsigned_int</td>
      </tr>
      <tr>
        <td>NUMERIC, FLOAT, REAL, MONEY, DECIMAL (MS SQL Server,
Sybase, DB2)</td>
        <td>otl_var_double</td>
        <td>otl_var_char, otl_var_int, otl_var_float, otl_var_short,
otl_var_unsigned_int,
otl_var_long_int</td>
      </tr>
      <tr>
        <td>INT (MS SQL Server, Sybase, DB2)</td>
        <td>otl_var_int</td>
        <td>otl_var_char, otl_var_double, otl_var_float, otl_var_short,
otl_var_unsigned_int,
otl_var_long_int</td>
      </tr>
      <tr>
        <td>SMALLINT, TINYINT (MS SQL Server, Sybase, DB2)</td>
        <td>otl_var_short</td>
        <td>otl_var_char, otl_var_int, otl_var_float, otl_var_double,
otl_var_unsigned_int,
otl_var_long_int</td>
      </tr>
      <tr>
        <td>DATE (Oracle), DATETIME (MS SQL Server, Sybase)</td>
        <td>otl_timestamp</td>
        <td>otl_var_char</td>
      </tr>
      <tr>
        <td>LONG (Oracle)</td>
        <td>otl_var_varchar_long</td>
        <td>otl_var_char (&lt;=32000 bytes)</td>
      </tr>
      <tr>
        <td>TEXT (MS SQL Server, Sybase)</td>
        <td>otl_var_varchar_long</td>
        <td>otl_var_char(&lt;= max. size of varchar, e.g. &lt;=8000 in
MS SQL 7.0)</td>
      </tr>
    </tbody>
  </table>
  </p>
  <p>It is recommended to use this function and datatype overrides with
caution.
This feature is introduced to address issues like: NUMBER is too large
to fit into the otl_var_double container and it is necessary to convert
the NUMBER into otl_var_char. Or, for small enough LONG or TEXT
columns,
sometimes it is more convenient to use the otl_var_char container. <br>
&nbsp;</p>
</blockquote>
<pre><font size="+2">}; // end of otl_stream</font></pre>
<center>
<hr width="100%">
<p><a href="otl3_class.htm">Prev</a> <a href="otl3_bind_variables.htm">Next</a><a
 href="otl3.htm">Contents</a><a href="home.htm">Go
Home</a></p>
</center>
<p>Copyright &copy; 1996, 2007, Sergei Kuchin, email: <a
 href="mailto:skuchin@ispwest.com">skuchin@ispwest.com</a>,
<a href="mailto:skuchin@gmail.com">skuchin@gmail.com
<script language="JavaScript"><!-- hide from old browsers
 var modDate = new Date(document.lastModified)
 document.write("<i> Last Updated:</i> " + (modDate.getMonth()+1) + "/" + 
                modDate.getDate() + "/" + "0"+(modDate.getYear())%100+".");
 //-->
 </script></a>.
</p>
<p><i>Permission to use, copy, modify and redistribute this document
for
any purpose is hereby granted without fee, provided that the above
copyright
notice appear in all copies.</i>
</p>
</body>
</html>
