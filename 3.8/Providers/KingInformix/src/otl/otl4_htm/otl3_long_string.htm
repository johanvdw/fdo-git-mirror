<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <meta name="Author" content="Sergei Kuchin">
  <meta name="GENERATOR"
 content="Mozilla/4.77 [en] (Win95; U) [Netscape]">
  <meta name="KeyWords"
 content="OTL, Oracle, ODBC, DB2, CLI, database API, C++, Template Library">
  <title>OTL 4.0, OTL Long String, Long Unicode String classes</title>
</head>
<body>
<center>
<h1>OTL 4.0, OTL Long String, Long Unicode String&nbsp; classes</h1>
</center>
<h1>
<a name="otl_class"></a>OTL Long String, Long Unicode String classes</h1>
These classes are used in operations with Large Objects (LOB). In OTL
4.0,
otl_long_string can hold a LOB of any type as well as RAW / BINARY: <br>
<ul>
  <li>Oracle 7: LONG, RAW, LONG RAW</li>
  <li>Oracle 8, 8i, 9i, 10g: LONG, RAW, LONG RAW; CLOB, BLOB</li>
  <li>MS SQL Server: TEXT, IMAGE, VARBINARY, BINARY</li>
  <li>DB2: CLOB, BLOB</li>
  <li>Sybase: TEXT, IMAGE, VARBINARY, BINARY<br>
  </li>
  <li>PostgreSQL: TEXT, BYTEA,<br>
  </li>
  <li>SAP/MAX DB: CHAR() BYTE, VARCHAR() BYTE, LONG VARCHAR, LONG
VARCHAR BYTE<br>
  </li>
  <li>MySQL: LONGTEXT, LONGBLOB, VARBINARY, BINARY</li>
</ul>
otl_long_unicode_string is specialized for Unicode character based
large
strings.
otl_long_unicode_string
can hold the following datatypes:
<ul>
  <li>Oracle 8i, 9i, 10g: LONG,&nbsp; CLOB; the database default
character set may
be set to ASCII, or UTF-8, etc</li>
  <li>Oracle 8i, 9i, 10g: NCLOB; the database national character set
may be set to
whatever is allowed for a concrete version of the database (8i and
9i/10g
differ
/ are not the same in that regard, as far as supporting different
versions
of Unicode, and what sets are allowed for national character datatypes)</li>
  <li>MS SQL NTEXT</li>
  <li>DB2 CLOB / DBCLOB when the database supports Unicode (UTF-8,
UCS-2, etc.)</li>
</ul>
In the case if Unicode OTL is enabled by #define <a
 href="otl3_compile.htm#OTL_UNICODE">OTL_UNICODE</a>,
otl_long_string needs to be used for Oracle LONG RAWs, BLOBs, MS SQL
IMAGEs, DB2 BLOBs, etc (large binary strings, generally speaking),
because
they still remain the large byte strings, without any character
semantic
attached.
<br>
<br>
OTL 4.0 defines the following <a href="otl3_bind_variables.htm">bind
variable
</a>datatypes for manipulating LOBs:
<ul>
  <li> <a href="otl3_bind_variables.htm#varchar_long">varchar_long</a>
for
Oracle
7/8/8i/9i/10g LONG, MS SQL Server/Sybase TEXT/NTEXT, DB2 CLOB/DBCLOB</li>
  <li> <a href="otl3_bind_variables.htm#raw_long">raw_long</a> for
Oracle
7/8/8i/9i/10g
RAW, LONG RAW, MS SQL Server/Sybase IMAGE, DB2 BLOB</li>
  <li> <a href="otl3_bind_variables.htm#clob">clob</a> for Oracle
8/8i/9i/10g
CLOB,
NCLOB (if #define OTL_UNICODE is enabled).</li>
  <li> <a href="otl3_bind_variables.htm#blob">blob </a>for Oracle
8/8i/9i/10g
BLOB</li>
</ul>
<h2>
<a name="LOB_and_NULL"></a><font size="+2">Large Objects (LOBs) and
NULLs</font></h2>
Behavior of LOBs is slightly different from the other table column
datatypes
as far as NULLs are concerned:
<ul>
  <li> <a name="LOB_LIST"></a>Oracle 7/8/8i/9i/10g's LONG, Oracle
7/8's LONG
RAW,
MS SQL Server/Sybase's TEXT, MS SQL Server/Sybase's IMAGE, DB2's
CLOB/BLOB:<br>
    <br>
  </li>
As opposed to normal dataypes of columns in tables, the above LOBs
can be set to NULL in two ways: either writing <a
 href="otl3_stream_class.htm#otl_null">otl_null</a>()
into the otl_stream or setting the length of the LOB to 0 by calling
otl_long_string::<a href="#set_len">set_len</a>(0)
and the writing the LOB into the otl_stream.
  <p>On the output, when the LOB is being read from the otl_stream, the
checking
for the NULL value can be done in two ways: either by calling
otl_stream::<a href="otl3_stream_class.htm#is_null">is_null</a>()
or by calling otl_long_string::<a href="#len">len</a>() and checking if
it returns 0. <br>
&nbsp; </p>
  <li>Oracle 8/8i/9i/10g's CLOB, Oracle 8/8i/9i/10g's BLOB:<br>
    <br>
  </li>
  <br>
On the input, behavior of Oracle's CLOBs and BLOBs is the same as the
other LOB datatypes, that is otl_null() or set_len(0) can be used when
writing a CLOB or BLOB into the database.
  <p>On the output, when the Oracle 8 CLOB/BLOB is being read from the
otl_stream,
the checking for the NULL value can be done only in one way by calling
otl_long_string::len() and checking if it returns 0. The
otl_stream::is_null()
function always returns 0 for CLOBs/BLOBs. So, it is recommended to use
the len() function and check it for 0 instead of using is_null().</p>
</ul>
<pre><font size="+2">class otl_long_string{<br>public:</font></pre>
<ul>
  <li>The <i>v </i>field is a pointer to the LOB value. In other
words, the
field
is a pointer to the LOB buffer.</li>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp; unsigned char* v;</pre>
<ul>
  <li> <a name="gen_constr0"></a>General constructor. It creates an
otl_long_string
instance: allocates memory for the LOB buffer and sets internal
variables.
The <i>buffer_size </i>parameter<i> </i>defines the size of the LOB
buffer.
By default, the size is 32760. In addition to setting the size of
otl_long_string,
the <a href="otl3_connect_class.htm#set_max_long_size">otl_connect::set_max_long_size</a>()
needs to be called with the same or a greater size.<br>
    <br>
  </li>
  <br>
The <i>input_length </i>parameter defines the actual length of the
string on the input. If this parameter is used, then the <a
 href="#set_len">set_len</a>()
function does not need to be called.
  <pre>&nbsp;&nbsp;&nbsp;&nbsp; otl_long_string(const int buffer_size=32760,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const int input_length=0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</pre>
</ul>
<ul>
  <li> <a name="gen_constr"></a>General constructor. It creates an
otl_long_string
instance: it sets the <i>v </i>field to the value of <i>external_buffer
    </i>and
sets internal variables. In case if this constructor is called, memory
for the LOB buffer is not allocated, the address of an external buffer
is used instead. This constructor is provided for more efficient
manipulation
of LOBs. If it is critical for performance or memory reasons, this
constructor
can be used for passing the address of a user defined buffer into the <a
 href="otl3_stream_class.htm">otl_stream</a>
opeations with LOBs.</li>
  <p><br>
The <i>buffer_size </i>parameter defines the size of the external
buffer for the otl_long_string. </p>
  <p>The <i>input_length </i>parameter the actual length of the
string on
the input. If this parameter is used, then there is no need to call the
  <a href="#set_len">set_len</a>()
function.</p>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp; otl_long_string(const void* external_buffer,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const int buffer_size,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const int input_length=0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</pre>
<ul>
  <li>This function sets the dynamic length of the LOB. The function
needs to
called before <a href="otl3_stream_class.htm#long_string_write">writing</a>
the LOB into the otl_stream. <br>
  </li>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="set_len"></a>void set_len(const int len=0);</pre>
<ul>
  <li>When an otl_long_string is used with an <a
 href="otl3_lob_stream.htm">otl_lob_stream</a> and OTL/OCI8i/9i/10g,
this function indicates that the otl_string_string is the last piece /
chunk in a sequence of LOB chunks being written into the
otl_lob_stream. The function exists for OTL/ODBC/DB2-CLI but it does
not haev any effect.<br>
  </li>
</ul>
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;<a
 style="font-family: monospace;" name="set_last_piece"></a><span
 style="font-family: monospace;">void set_last_piece(const bool
last_piece=false);</span>
<ul>
  <li>This function returns the dynimac length of the LOB. The function
needs
to be called after <a href="otl3_stream_class.htm#long_string_read">reading</a>
the LOB from the otl_stream</li>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="len"></a>int len(void);</pre>
<ul>
  <li>This operator allows the user to access individual bytes of the
LOB.</li>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp; unsigned char&amp; operator[](int ndx);<br><br></pre>
<ul>
  <li>Assignment operator<br>
    <br>
    <pre>otl_long_string&amp; operator=(const otl_long_string&amp;);<br></pre>
  </li>
  <li>Copy constructor<br>
    <pre>otl_long_string(const otl_long_string&amp;);<br></pre>
  </li>
</ul>
<pre><font size="+2">}; // end of otl_long_string<br><br><a
 name="otl_long_unicode_string"></a>class otl_long_unicode_string: public otl_long_string{<br>public:</font></pre>
<ul>
  <li> <a name="unicode_gen_constr0"></a>General constructor. It
creates
an otl_long_unicode_string
instance: allocates memory for the LOB buffer and sets internal
variables.
The <i>buffer_size </i>parameter<i> </i>defines the size of the LOB
buffer.
By default, the size is 32760 Unicode characters. In addition to
setting
the size of otl_long_unicode_string, the <a
 href="otl3_connect_class.htm#set_max_long_size">otl_connect::set_max_long_size</a>()
needs to be called with the same or a greater size.Note: all sizes for
Unicode strings are given not in bytes but in Unicode characters (2
bytes
per character times 2 to accomodate a possible surrogate character).<br>
    <br>
  </li>
  <br>
The <i>input_length </i>parameter defines the actual length of the
string on the input. If this parameter is used, then the <a
 href="#unicode_set_len">set_len</a>()
function does not need to be called.
  <pre>&nbsp;&nbsp;&nbsp;&nbsp; otl_long_unicode_string(const int buffer_size=32760,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const int input_length=0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</pre>
</ul>
<ul>
  <li> <a name="unicode_gen_constr"></a>General constructor. It
creates an
otl_long_unicode_string
instance: it saves the value of <i>external_buffer </i>and sets
internal
variables. In case if this constructor is called, memory for the LOB
buffer
is not allocated, the address of an external buffer is used instead.
This
constructor is provided for more efficient manipulation of LOBs. If it
is critical for performance or memory reasons, this constructor can be
used for passing the address of a user defined buffer into the <a
 href="otl3_stream_class.htm">otl_stream</a>
opeations with LOBs.<br>
    <br>
  </li>
  <br>
The <i>buffer_size </i>parameter defines the size of the external
buffer
for the otl_long_unicode_string.
  <p>The <i>input_length </i>parameter the actual length of the
string on
the input. If this parameter is used, then there is no need to call the
  <a href="#unicode_set_len">set_len</a>()
function.</p>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp; otl_long_unicode_string(const void* external_buffer,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const int buffer_size,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const int input_length=0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</pre>
<ul>
  <li>This function sets the dynamic length of the LOB in Unicode
characters
(2 bytes per each). The function needs to called before <a
 href="otl3_stream_class.htm#long_string_write">writing</a>
the LOB into the otl_stream</li>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="unicode_set_len"></a>void set_len(const int len=0);</pre>
<ul>
  <li>This function returns the dynimac length of the LOB in Unicode
characters
(2 bytes per character). The function needs to be called after <a
 href="otl3_stream_class.htm#long_string_read">reading</a>
the LOB from the otl_stream</li>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="unicode_len"></a>int len(void);</pre>
<ul>
  <li>This operator allows the user to access individual Unicode
characters
of
the LOB.</li>
</ul>
<pre>&nbsp;&nbsp;&nbsp;&nbsp; unsigned short&amp; operator[](int ndx);</pre>
<pre><font size="+2">}; // end of otl_long_unicode_string</font></pre>
<hr width="100%">
<center>
<p><a href="otl3_exception_class.htm">Prev</a> <a
 href="otl3_const_sql.htm">Next</a><a href="otl3.htm">Contents</a><a
 href="home.htm">Go
Home</a></p>
</center>
<p>Copyright &copy; 1996, 2007, Sergei Kuchin, email: <a
 href="mailto:skuchin@ispwest.com">skuchin@ispwest.com</a>,
<a href="mailto:skuchin@gmail.com">skuchin@gmail.com
<script language="JavaScript"><!-- hide from old browsers
 var modDate = new Date(document.lastModified)
 document.write("<i> Last Updated:</i> " + (modDate.getMonth()+1) + "/" + 
                modDate.getDate() + "/" + "0"+(modDate.getYear())%100+".");
 //-->
 </script></a>.
</p>
<p><i>Permission to use, copy, modify and redistribute this document
for
any purpose is hereby granted without fee, provided that the above
copyright
notice appear in all copies.</i>
</p>
</body>
</html>
